/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AudioRecorderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  recordingsFolder: "Recordings",
  recordMicrophone: true,
  selectedMicrophoneId: "default",
  muteHotkey: "CommandOrControl+Shift+M"
  // Default global hotkey
};
var AudioRecorderPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.recorder = null;
    this.chunks = [];
    this.recordingStream = null;
    this.micStream = null;
    this.audioContext = null;
    this.micGainNode = null;
    this.isMicMuted = false;
    this.analyserNode = null;
    this.statusBarItem = null;
    this.activeFileAtStart = null;
    this.controlWindow = null;
    // BrowserWindow
    this.processorNode = null;
    this.muteGainNode = null;
    this.electron = null;
  }
  // Electron reference
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon(
      "microphone",
      "Start/Stop Recording",
      (evt) => {
        this.toggleRecording();
      }
    );
    ribbonIconEl.addClass("audio-recorder-ribbon-class");
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("");
    this.addCommand({
      id: "start-stop-recording",
      name: "Start/Stop Recording",
      callback: () => {
        this.toggleRecording();
      }
    });
    this.addCommand({
      id: "toggle-mic-mute",
      name: "Toggle Microphone Mute",
      callback: () => {
        this.toggleMute();
      }
    });
    this.addSettingTab(new AudioRecorderSettingTab(this.app, this));
  }
  onunload() {
    this.stopRecording();
    this.unregisterGlobalHotkey();
  }
  async toggleRecording() {
    if (this.recorder && this.recorder.state === "recording") {
      this.stopRecording();
    } else {
      this.startRecording();
    }
  }
  toggleMute() {
    if (!this.recorder || this.recorder.state !== "recording") {
      new import_obsidian.Notice("No active recording to mute/unmute microphone.");
      return;
    }
    if (!this.micGainNode) {
      new import_obsidian.Notice("Microphone is not being recorded.");
      return;
    }
    this.isMicMuted = !this.isMicMuted;
    this.micGainNode.gain.value = this.isMicMuted ? 0 : 1;
    if (this.controlWindow && !this.controlWindow.isDestroyed()) {
      this.controlWindow.webContents.send("toggle-mute-state", this.isMicMuted);
    }
    new import_obsidian.Notice(this.isMicMuted ? "Microphone muted" : "Microphone unmuted");
  }
  async startRecording() {
    var _a;
    try {
      this.activeFileAtStart = this.app.workspace.getActiveFile();
      const electron = require("electron");
      this.electron = electron;
      let desktopCapturer = electron.desktopCapturer;
      let remote = electron.remote;
      if (!desktopCapturer && remote) {
        desktopCapturer = remote.desktopCapturer;
      }
      if (!desktopCapturer) {
        new import_obsidian.Notice("Error: desktopCapturer API is not available.");
        return;
      }
      this.registerGlobalHotkey();
      const sources = await desktopCapturer.getSources({ types: ["screen"] });
      if (sources.length === 0) {
        new import_obsidian.Notice("No screen sources found.");
        return;
      }
      const source = sources[0];
      const systemStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: source.id
          }
        },
        video: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: source.id
          }
        }
      });
      const systemAudioTracks = systemStream.getAudioTracks();
      if (systemAudioTracks.length === 0) {
        new import_obsidian.Notice(
          "No system audio track captured. Ensure you are on Windows or have system audio setup."
        );
      }
      this.recordingStream = systemStream;
      if (this.settings.recordMicrophone) {
        try {
          const constraints = { audio: true };
          if (this.settings.selectedMicrophoneId && this.settings.selectedMicrophoneId !== "default") {
            constraints.audio = {
              deviceId: { exact: this.settings.selectedMicrophoneId }
            };
          }
          this.micStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (micErr) {
          console.error("Error capturing microphone:", micErr);
          new import_obsidian.Notice(
            "Failed to capture microphone. Recording system audio only."
          );
        }
      }
      let finalStream;
      this.audioContext = new AudioContext();
      const destination = this.audioContext.createMediaStreamDestination();
      const masterGain = this.audioContext.createGain();
      masterGain.connect(destination);
      this.analyserNode = this.audioContext.createAnalyser();
      this.analyserNode.fftSize = 128;
      this.analyserNode.smoothingTimeConstant = 0.5;
      masterGain.connect(this.analyserNode);
      if (systemAudioTracks.length > 0) {
        const systemSource = this.audioContext.createMediaStreamSource(systemStream);
        systemSource.connect(masterGain);
      }
      if (this.micStream) {
        const micSource = this.audioContext.createMediaStreamSource(
          this.micStream
        );
        this.micGainNode = this.audioContext.createGain();
        this.micGainNode.gain.value = 1;
        micSource.connect(this.micGainNode);
        this.micGainNode.connect(masterGain);
      }
      finalStream = destination.stream;
      if (finalStream.getAudioTracks().length === 0) {
        new import_obsidian.Notice("No audio tracks available to record.");
        this.stopRecordingStreams();
        return;
      }
      this.recorder = new MediaRecorder(finalStream, {
        mimeType: "audio/webm"
      });
      this.chunks = [];
      this.recorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          this.chunks.push(e.data);
        }
      };
      this.recorder.onstop = async () => {
        var _a2;
        const blob = new Blob(this.chunks, { type: "audio/webm" });
        await this.saveRecording(blob);
        this.stopRecordingStreams();
        (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText("");
        new import_obsidian.Notice("Recording saved.");
        this.closeControlWindow();
      };
      this.recorder.start();
      (_a = this.statusBarItem) == null ? void 0 : _a.setText("Recording...");
      new import_obsidian.Notice("Recording started.");
      this.openControlWindow(electron);
      this.startAudioVisualization();
    } catch (err) {
      console.error("Error starting recording:", err);
      new import_obsidian.Notice("Failed to start recording. See console for details.");
      this.stopRecordingStreams();
    }
  }
  openControlWindow(electron) {
    const remote = electron.remote || electron;
    const BrowserWindow = remote.BrowserWindow;
    const ipcMain = remote.ipcMain;
    const { width, height } = remote.screen.getPrimaryDisplay().workAreaSize;
    this.controlWindow = new BrowserWindow({
      width: 320,
      height: 110,
      frame: false,
      transparent: true,
      backgroundColor: "#00000000",
      // Force transparency
      hasShadow: false,
      // Disable native shadow to prevent black corners
      alwaysOnTop: true,
      resizable: false,
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        backgroundThrottling: false
        // Prevent throttling when in background
      },
      x: Math.floor(width / 2 - 160),
      y: height - 110
    });
    const pluginDir = this.app.vault.adapter.basePath + "/" + this.manifest.dir;
    const htmlPath = path.join(pluginDir, "control-window.html");
    this.controlWindow.loadFile(htmlPath);
    this.controlWindow.webContents.on("did-finish-load", () => {
      const accentColor = getComputedStyle(document.body).getPropertyValue(
        "--interactive-accent"
      ) || "#7c3aed";
      this.controlWindow.webContents.send("set-accent-color", accentColor);
    });
    const onMuteMic = () => {
      if (this.micGainNode) {
        this.micGainNode.gain.value = 0;
        this.isMicMuted = true;
      }
    };
    const onUnmuteMic = () => {
      if (this.micGainNode) {
        this.micGainNode.gain.value = 1;
        this.isMicMuted = false;
      }
    };
    const onStopRecording = () => {
      this.stopRecording();
    };
    ipcMain.on("mute-mic", onMuteMic);
    ipcMain.on("unmute-mic", onUnmuteMic);
    ipcMain.on("stop-recording", onStopRecording);
    this.controlWindow.on("closed", () => {
      ipcMain.removeListener("mute-mic", onMuteMic);
      ipcMain.removeListener("unmute-mic", onUnmuteMic);
      ipcMain.removeListener("stop-recording", onStopRecording);
      this.controlWindow = null;
    });
  }
  closeControlWindow() {
    if (this.controlWindow) {
      this.controlWindow.close();
      this.controlWindow = null;
    }
    if (this.processorNode) {
      this.processorNode.disconnect();
      this.processorNode = null;
    }
    if (this.muteGainNode) {
      this.muteGainNode.disconnect();
      this.muteGainNode = null;
    }
  }
  startAudioVisualization() {
    if (!this.analyserNode || !this.controlWindow || !this.audioContext)
      return;
    const dataArray = new Uint8Array(this.analyserNode.frequencyBinCount);
    this.processorNode = this.audioContext.createScriptProcessor(2048, 1, 1);
    this.muteGainNode = this.audioContext.createGain();
    this.muteGainNode.gain.value = 0;
    this.analyserNode.connect(this.processorNode);
    this.processorNode.connect(this.muteGainNode);
    this.muteGainNode.connect(this.audioContext.destination);
    this.processorNode.onaudioprocess = () => {
      if (!this.analyserNode || !this.controlWindow) {
        if (this.processorNode) {
          this.processorNode.disconnect();
          this.processorNode = null;
        }
        return;
      }
      this.analyserNode.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const average = sum / dataArray.length / 255;
      try {
        if (!this.controlWindow.isDestroyed()) {
          this.controlWindow.webContents.send("audio-level", average);
        }
      } catch (err) {
      }
    };
  }
  stopRecording() {
    if (this.recorder && this.recorder.state === "recording") {
      this.recorder.stop();
    }
    this.unregisterGlobalHotkey();
  }
  stopRecordingStreams() {
    if (this.recordingStream) {
      this.recordingStream.getTracks().forEach((track) => track.stop());
      this.recordingStream = null;
    }
    if (this.micStream) {
      this.micStream.getTracks().forEach((track) => track.stop());
      this.micStream = null;
    }
    if (this.processorNode) {
      this.processorNode.disconnect();
      this.processorNode = null;
    }
    if (this.muteGainNode) {
      this.muteGainNode.disconnect();
      this.muteGainNode = null;
    }
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
    this.recorder = null;
  }
  registerGlobalHotkey() {
    if (!this.electron || !this.settings.muteHotkey)
      return;
    try {
      const remote = this.electron.remote || this.electron;
      const { globalShortcut } = remote;
      this.unregisterGlobalHotkey();
      const registered = globalShortcut.register(
        this.settings.muteHotkey,
        () => {
          this.toggleMute();
        }
      );
      if (!registered) {
        console.warn(
          `Failed to register global hotkey: ${this.settings.muteHotkey}`
        );
      }
    } catch (err) {
      console.error("Error registering global hotkey:", err);
    }
  }
  unregisterGlobalHotkey() {
    if (!this.electron || !this.settings.muteHotkey)
      return;
    try {
      const remote = this.electron.remote || this.electron;
      const { globalShortcut } = remote;
      if (globalShortcut.isRegistered(this.settings.muteHotkey)) {
        globalShortcut.unregister(this.settings.muteHotkey);
      }
    } catch (err) {
      console.error("Error unregistering global hotkey:", err);
    }
  }
  async saveRecording(blob) {
    const arrayBuffer = await blob.arrayBuffer();
    const buffer = new Uint8Array(arrayBuffer);
    const folderPath = this.settings.recordingsFolder;
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
    const now = new Date();
    const timestamp = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, "0")}-${now.getDate().toString().padStart(2, "0")} ${now.getHours().toString().padStart(2, "0")}.${now.getMinutes().toString().padStart(2, "0")}.${now.getSeconds().toString().padStart(2, "0")}`;
    const filename = `${folderPath}/Recording ${timestamp}.webm`;
    const file = await this.app.vault.createBinary(filename, buffer);
    if (this.activeFileAtStart) {
      const linkText = `
![[${file.path}]]
`;
      await this.app.vault.append(this.activeFileAtStart, linkText);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AudioRecorderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Audio Recorder" });
    new import_obsidian.Setting(containerEl).setName("Recordings Folder").setDesc("Folder to save audio recordings in").addText(
      (text) => text.setPlaceholder("Recordings").setValue(this.plugin.settings.recordingsFolder).onChange(async (value) => {
        this.plugin.settings.recordingsFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Record Microphone").setDesc("Record microphone audio along with system audio.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.recordMicrophone).onChange(async (value) => {
        this.plugin.settings.recordMicrophone = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Microphone Source").setDesc("Select the microphone to record.").addDropdown(async (dropdown) => {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter((d) => d.kind === "audioinput");
      audioInputs.forEach((device) => {
        dropdown.addOption(
          device.deviceId,
          device.label || `Microphone ${device.deviceId}`
        );
      });
      dropdown.setValue(this.plugin.settings.selectedMicrophoneId);
      dropdown.onChange(async (value) => {
        this.plugin.settings.selectedMicrophoneId = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Hotkeys" });
    new import_obsidian.Setting(containerEl).setName("Global Mute Hotkey").setDesc(
      "Set a system-wide hotkey to toggle microphone muting (works even when Obsidian isn't focused). Uses Electron's accelerator format. Examples: 'CommandOrControl+Shift+M', 'Alt+M', 'Ctrl+Shift+Space'. Changes take effect when starting a new recording."
    ).addText(
      (text) => text.setPlaceholder("CommandOrControl+Shift+M").setValue(this.plugin.settings.muteHotkey).onChange(async (value) => {
        this.plugin.settings.muteHotkey = value;
        await this.plugin.saveSettings();
      })
    );
    const hotkeyDesc = containerEl.createDiv();
    hotkeyDesc.addClass("setting-item-description");
    hotkeyDesc.setText(
      "You can also use Obsidian's built-in hotkeys (Settings \u2192 Hotkeys \u2192 'Toggle Microphone Mute'), but those only work when Obsidian is focused."
    );
    hotkeyDesc.style.marginBottom = "1em";
  }
};
