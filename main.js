/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/fix-webm-duration/fix-webm-duration.js
var require_fix_webm_duration = __commonJS({
  "node_modules/fix-webm-duration/fix-webm-duration.js"(exports, module2) {
    (function(name, definition) {
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = definition();
      } else {
        window.ysFixWebmDuration = definition();
      }
    })("fix-webm-duration", function() {
      var sections = {
        172351395: { name: "EBML", type: "Container" },
        646: { name: "EBMLVersion", type: "Uint" },
        759: { name: "EBMLReadVersion", type: "Uint" },
        754: { name: "EBMLMaxIDLength", type: "Uint" },
        755: { name: "EBMLMaxSizeLength", type: "Uint" },
        642: { name: "DocType", type: "String" },
        647: { name: "DocTypeVersion", type: "Uint" },
        645: { name: "DocTypeReadVersion", type: "Uint" },
        108: { name: "Void", type: "Binary" },
        63: { name: "CRC-32", type: "Binary" },
        190023271: { name: "SignatureSlot", type: "Container" },
        16010: { name: "SignatureAlgo", type: "Uint" },
        16026: { name: "SignatureHash", type: "Uint" },
        16037: { name: "SignaturePublicKey", type: "Binary" },
        16053: { name: "Signature", type: "Binary" },
        15963: { name: "SignatureElements", type: "Container" },
        15995: { name: "SignatureElementList", type: "Container" },
        9522: { name: "SignedElement", type: "Binary" },
        139690087: { name: "Segment", type: "Container" },
        21863284: { name: "SeekHead", type: "Container" },
        3515: { name: "Seek", type: "Container" },
        5035: { name: "SeekID", type: "Binary" },
        5036: { name: "SeekPosition", type: "Uint" },
        88713574: { name: "Info", type: "Container" },
        13220: { name: "SegmentUID", type: "Binary" },
        13188: { name: "SegmentFilename", type: "String" },
        1882403: { name: "PrevUID", type: "Binary" },
        1868715: { name: "PrevFilename", type: "String" },
        2013475: { name: "NextUID", type: "Binary" },
        1999803: { name: "NextFilename", type: "String" },
        1092: { name: "SegmentFamily", type: "Binary" },
        10532: { name: "ChapterTranslate", type: "Container" },
        10748: { name: "ChapterTranslateEditionUID", type: "Uint" },
        10687: { name: "ChapterTranslateCodec", type: "Uint" },
        10661: { name: "ChapterTranslateID", type: "Binary" },
        710577: { name: "TimecodeScale", type: "Uint" },
        1161: { name: "Duration", type: "Float" },
        1121: { name: "DateUTC", type: "Date" },
        15273: { name: "Title", type: "String" },
        3456: { name: "MuxingApp", type: "String" },
        5953: { name: "WritingApp", type: "String" },
        // 0xf43b675: { name: 'Cluster', type: 'Container' },
        103: { name: "Timecode", type: "Uint" },
        6228: { name: "SilentTracks", type: "Container" },
        6359: { name: "SilentTrackNumber", type: "Uint" },
        39: { name: "Position", type: "Uint" },
        43: { name: "PrevSize", type: "Uint" },
        35: { name: "SimpleBlock", type: "Binary" },
        32: { name: "BlockGroup", type: "Container" },
        33: { name: "Block", type: "Binary" },
        34: { name: "BlockVirtual", type: "Binary" },
        13729: { name: "BlockAdditions", type: "Container" },
        38: { name: "BlockMore", type: "Container" },
        110: { name: "BlockAddID", type: "Uint" },
        37: { name: "BlockAdditional", type: "Binary" },
        27: { name: "BlockDuration", type: "Uint" },
        122: { name: "ReferencePriority", type: "Uint" },
        123: { name: "ReferenceBlock", type: "Int" },
        125: { name: "ReferenceVirtual", type: "Int" },
        36: { name: "CodecState", type: "Binary" },
        13730: { name: "DiscardPadding", type: "Int" },
        14: { name: "Slices", type: "Container" },
        104: { name: "TimeSlice", type: "Container" },
        76: { name: "LaceNumber", type: "Uint" },
        77: { name: "FrameNumber", type: "Uint" },
        75: { name: "BlockAdditionID", type: "Uint" },
        78: { name: "Delay", type: "Uint" },
        79: { name: "SliceDuration", type: "Uint" },
        72: { name: "ReferenceFrame", type: "Container" },
        73: { name: "ReferenceOffset", type: "Uint" },
        74: { name: "ReferenceTimeCode", type: "Uint" },
        47: { name: "EncryptedBlock", type: "Binary" },
        106212971: { name: "Tracks", type: "Container" },
        46: { name: "TrackEntry", type: "Container" },
        87: { name: "TrackNumber", type: "Uint" },
        13253: { name: "TrackUID", type: "Uint" },
        3: { name: "TrackType", type: "Uint" },
        57: { name: "FlagEnabled", type: "Uint" },
        8: { name: "FlagDefault", type: "Uint" },
        5546: { name: "FlagForced", type: "Uint" },
        28: { name: "FlagLacing", type: "Uint" },
        11751: { name: "MinCache", type: "Uint" },
        11768: { name: "MaxCache", type: "Uint" },
        254851: { name: "DefaultDuration", type: "Uint" },
        216698: { name: "DefaultDecodedFieldDuration", type: "Uint" },
        209231: { name: "TrackTimecodeScale", type: "Float" },
        4991: { name: "TrackOffset", type: "Int" },
        5614: { name: "MaxBlockAdditionID", type: "Uint" },
        4974: { name: "Name", type: "String" },
        177564: { name: "Language", type: "String" },
        6: { name: "CodecID", type: "String" },
        9122: { name: "CodecPrivate", type: "Binary" },
        362120: { name: "CodecName", type: "String" },
        13382: { name: "AttachmentLink", type: "Uint" },
        1742487: { name: "CodecSettings", type: "String" },
        1785920: { name: "CodecInfoURL", type: "String" },
        438848: { name: "CodecDownloadURL", type: "String" },
        42: { name: "CodecDecodeAll", type: "Uint" },
        12203: { name: "TrackOverlay", type: "Uint" },
        5802: { name: "CodecDelay", type: "Uint" },
        5819: { name: "SeekPreRoll", type: "Uint" },
        9764: { name: "TrackTranslate", type: "Container" },
        9980: { name: "TrackTranslateEditionUID", type: "Uint" },
        9919: { name: "TrackTranslateCodec", type: "Uint" },
        9893: { name: "TrackTranslateTrackID", type: "Binary" },
        96: { name: "Video", type: "Container" },
        26: { name: "FlagInterlaced", type: "Uint" },
        5048: { name: "StereoMode", type: "Uint" },
        5056: { name: "AlphaMode", type: "Uint" },
        5049: { name: "OldStereoMode", type: "Uint" },
        48: { name: "PixelWidth", type: "Uint" },
        58: { name: "PixelHeight", type: "Uint" },
        5290: { name: "PixelCropBottom", type: "Uint" },
        5307: { name: "PixelCropTop", type: "Uint" },
        5324: { name: "PixelCropLeft", type: "Uint" },
        5341: { name: "PixelCropRight", type: "Uint" },
        5296: { name: "DisplayWidth", type: "Uint" },
        5306: { name: "DisplayHeight", type: "Uint" },
        5298: { name: "DisplayUnit", type: "Uint" },
        5299: { name: "AspectRatioType", type: "Uint" },
        963876: { name: "ColourSpace", type: "Binary" },
        1029411: { name: "GammaValue", type: "Float" },
        230371: { name: "FrameRate", type: "Float" },
        97: { name: "Audio", type: "Container" },
        53: { name: "SamplingFrequency", type: "Float" },
        14517: { name: "OutputSamplingFrequency", type: "Float" },
        31: { name: "Channels", type: "Uint" },
        15739: { name: "ChannelPositions", type: "Binary" },
        8804: { name: "BitDepth", type: "Uint" },
        98: { name: "TrackOperation", type: "Container" },
        99: { name: "TrackCombinePlanes", type: "Container" },
        100: { name: "TrackPlane", type: "Container" },
        101: { name: "TrackPlaneUID", type: "Uint" },
        102: { name: "TrackPlaneType", type: "Uint" },
        105: { name: "TrackJoinBlocks", type: "Container" },
        109: { name: "TrackJoinUID", type: "Uint" },
        64: { name: "TrickTrackUID", type: "Uint" },
        65: { name: "TrickTrackSegmentUID", type: "Binary" },
        70: { name: "TrickTrackFlag", type: "Uint" },
        71: { name: "TrickMasterTrackUID", type: "Uint" },
        68: { name: "TrickMasterTrackSegmentUID", type: "Binary" },
        11648: { name: "ContentEncodings", type: "Container" },
        8768: { name: "ContentEncoding", type: "Container" },
        4145: { name: "ContentEncodingOrder", type: "Uint" },
        4146: { name: "ContentEncodingScope", type: "Uint" },
        4147: { name: "ContentEncodingType", type: "Uint" },
        4148: { name: "ContentCompression", type: "Container" },
        596: { name: "ContentCompAlgo", type: "Uint" },
        597: { name: "ContentCompSettings", type: "Binary" },
        4149: { name: "ContentEncryption", type: "Container" },
        2017: { name: "ContentEncAlgo", type: "Uint" },
        2018: { name: "ContentEncKeyID", type: "Binary" },
        2019: { name: "ContentSignature", type: "Binary" },
        2020: { name: "ContentSigKeyID", type: "Binary" },
        2021: { name: "ContentSigAlgo", type: "Uint" },
        2022: { name: "ContentSigHashAlgo", type: "Uint" },
        206814059: { name: "Cues", type: "Container" },
        59: { name: "CuePoint", type: "Container" },
        51: { name: "CueTime", type: "Uint" },
        55: { name: "CueTrackPositions", type: "Container" },
        119: { name: "CueTrack", type: "Uint" },
        113: { name: "CueClusterPosition", type: "Uint" },
        112: { name: "CueRelativePosition", type: "Uint" },
        50: { name: "CueDuration", type: "Uint" },
        4984: { name: "CueBlockNumber", type: "Uint" },
        106: { name: "CueCodecState", type: "Uint" },
        91: { name: "CueReference", type: "Container" },
        22: { name: "CueRefTime", type: "Uint" },
        23: { name: "CueRefCluster", type: "Uint" },
        4959: { name: "CueRefNumber", type: "Uint" },
        107: { name: "CueRefCodecState", type: "Uint" },
        155296873: { name: "Attachments", type: "Container" },
        8615: { name: "AttachedFile", type: "Container" },
        1662: { name: "FileDescription", type: "String" },
        1646: { name: "FileName", type: "String" },
        1632: { name: "FileMimeType", type: "String" },
        1628: { name: "FileData", type: "Binary" },
        1710: { name: "FileUID", type: "Uint" },
        1653: { name: "FileReferral", type: "Binary" },
        1633: { name: "FileUsedStartTime", type: "Uint" },
        1634: { name: "FileUsedEndTime", type: "Uint" },
        4433776: { name: "Chapters", type: "Container" },
        1465: { name: "EditionEntry", type: "Container" },
        1468: { name: "EditionUID", type: "Uint" },
        1469: { name: "EditionFlagHidden", type: "Uint" },
        1499: { name: "EditionFlagDefault", type: "Uint" },
        1501: { name: "EditionFlagOrdered", type: "Uint" },
        54: { name: "ChapterAtom", type: "Container" },
        13252: { name: "ChapterUID", type: "Uint" },
        5716: { name: "ChapterStringUID", type: "String" },
        17: { name: "ChapterTimeStart", type: "Uint" },
        18: { name: "ChapterTimeEnd", type: "Uint" },
        24: { name: "ChapterFlagHidden", type: "Uint" },
        1432: { name: "ChapterFlagEnabled", type: "Uint" },
        11879: { name: "ChapterSegmentUID", type: "Binary" },
        11964: { name: "ChapterSegmentEditionUID", type: "Uint" },
        9155: { name: "ChapterPhysicalEquiv", type: "Uint" },
        15: { name: "ChapterTrack", type: "Container" },
        9: { name: "ChapterTrackNumber", type: "Uint" },
        0: { name: "ChapterDisplay", type: "Container" },
        5: { name: "ChapString", type: "String" },
        892: { name: "ChapLanguage", type: "String" },
        894: { name: "ChapCountry", type: "String" },
        10564: { name: "ChapProcess", type: "Container" },
        10581: { name: "ChapProcessCodecID", type: "Uint" },
        1293: { name: "ChapProcessPrivate", type: "Binary" },
        10513: { name: "ChapProcessCommand", type: "Container" },
        10530: { name: "ChapProcessTime", type: "Uint" },
        10547: { name: "ChapProcessData", type: "Binary" },
        39109479: { name: "Tags", type: "Container" },
        13171: { name: "Tag", type: "Container" },
        9152: { name: "Targets", type: "Container" },
        10442: { name: "TargetTypeValue", type: "Uint" },
        9162: { name: "TargetType", type: "String" },
        9157: { name: "TagTrackUID", type: "Uint" },
        9161: { name: "TagEditionUID", type: "Uint" },
        9156: { name: "TagChapterUID", type: "Uint" },
        9158: { name: "TagAttachmentUID", type: "Uint" },
        10184: { name: "SimpleTag", type: "Container" },
        1443: { name: "TagName", type: "String" },
        1146: { name: "TagLanguage", type: "String" },
        1156: { name: "TagDefault", type: "Uint" },
        1159: { name: "TagString", type: "String" },
        1157: { name: "TagBinary", type: "Binary" }
      };
      function doInherit(newClass, baseClass) {
        newClass.prototype = Object.create(baseClass.prototype);
        newClass.prototype.constructor = newClass;
      }
      function WebmBase(name, type) {
        this.name = name || "Unknown";
        this.type = type || "Unknown";
      }
      WebmBase.prototype.updateBySource = function() {
      };
      WebmBase.prototype.setSource = function(source) {
        this.source = source;
        this.updateBySource();
      };
      WebmBase.prototype.updateByData = function() {
      };
      WebmBase.prototype.setData = function(data) {
        this.data = data;
        this.updateByData();
      };
      function WebmUint(name, type) {
        WebmBase.call(this, name, type || "Uint");
      }
      doInherit(WebmUint, WebmBase);
      function padHex(hex) {
        return hex.length % 2 === 1 ? "0" + hex : hex;
      }
      WebmUint.prototype.updateBySource = function() {
        this.data = "";
        for (var i = 0; i < this.source.length; i++) {
          var hex = this.source[i].toString(16);
          this.data += padHex(hex);
        }
      };
      WebmUint.prototype.updateByData = function() {
        var length = this.data.length / 2;
        this.source = new Uint8Array(length);
        for (var i = 0; i < length; i++) {
          var hex = this.data.substr(i * 2, 2);
          this.source[i] = parseInt(hex, 16);
        }
      };
      WebmUint.prototype.getValue = function() {
        return parseInt(this.data, 16);
      };
      WebmUint.prototype.setValue = function(value) {
        this.setData(padHex(value.toString(16)));
      };
      function WebmFloat(name, type) {
        WebmBase.call(this, name, type || "Float");
      }
      doInherit(WebmFloat, WebmBase);
      WebmFloat.prototype.getFloatArrayType = function() {
        return this.source && this.source.length === 4 ? Float32Array : Float64Array;
      };
      WebmFloat.prototype.updateBySource = function() {
        var byteArray = this.source.reverse();
        var floatArrayType = this.getFloatArrayType();
        var floatArray = new floatArrayType(byteArray.buffer);
        this.data = floatArray[0];
      };
      WebmFloat.prototype.updateByData = function() {
        var floatArrayType = this.getFloatArrayType();
        var floatArray = new floatArrayType([this.data]);
        var byteArray = new Uint8Array(floatArray.buffer);
        this.source = byteArray.reverse();
      };
      WebmFloat.prototype.getValue = function() {
        return this.data;
      };
      WebmFloat.prototype.setValue = function(value) {
        this.setData(value);
      };
      function WebmContainer(name, type) {
        WebmBase.call(this, name, type || "Container");
      }
      doInherit(WebmContainer, WebmBase);
      WebmContainer.prototype.readByte = function() {
        return this.source[this.offset++];
      };
      WebmContainer.prototype.readUint = function() {
        var firstByte = this.readByte();
        var bytes = 8 - firstByte.toString(2).length;
        var value = firstByte - (1 << 7 - bytes);
        for (var i = 0; i < bytes; i++) {
          value *= 256;
          value += this.readByte();
        }
        return value;
      };
      WebmContainer.prototype.updateBySource = function() {
        this.data = [];
        for (this.offset = 0; this.offset < this.source.length; this.offset = end) {
          var id = this.readUint();
          var len = this.readUint();
          var end = Math.min(this.offset + len, this.source.length);
          var data = this.source.slice(this.offset, end);
          var info = sections[id] || { name: "Unknown", type: "Unknown" };
          var ctr = WebmBase;
          switch (info.type) {
            case "Container":
              ctr = WebmContainer;
              break;
            case "Uint":
              ctr = WebmUint;
              break;
            case "Float":
              ctr = WebmFloat;
              break;
          }
          var section = new ctr(info.name, info.type);
          section.setSource(data);
          this.data.push({
            id,
            idHex: id.toString(16),
            data: section
          });
        }
      };
      WebmContainer.prototype.writeUint = function(x, draft) {
        for (var bytes = 1, flag = 128; x >= flag && bytes < 8; bytes++, flag *= 128) {
        }
        if (!draft) {
          var value = flag + x;
          for (var i = bytes - 1; i >= 0; i--) {
            var c = value % 256;
            this.source[this.offset + i] = c;
            value = (value - c) / 256;
          }
        }
        this.offset += bytes;
      };
      WebmContainer.prototype.writeSections = function(draft) {
        this.offset = 0;
        for (var i = 0; i < this.data.length; i++) {
          var section = this.data[i], content = section.data.source, contentLength = content.length;
          this.writeUint(section.id, draft);
          this.writeUint(contentLength, draft);
          if (!draft) {
            this.source.set(content, this.offset);
          }
          this.offset += contentLength;
        }
        return this.offset;
      };
      WebmContainer.prototype.updateByData = function() {
        var length = this.writeSections("draft");
        this.source = new Uint8Array(length);
        this.writeSections();
      };
      WebmContainer.prototype.getSectionById = function(id) {
        for (var i = 0; i < this.data.length; i++) {
          var section = this.data[i];
          if (section.id === id) {
            return section.data;
          }
        }
        return null;
      };
      function WebmFile(source) {
        WebmContainer.call(this, "File", "File");
        this.setSource(source);
      }
      doInherit(WebmFile, WebmContainer);
      WebmFile.prototype.fixDuration = function(duration, options) {
        var logger = options && options.logger;
        if (logger === void 0) {
          logger = function(message) {
            console.log(message);
          };
        } else if (!logger) {
          logger = function() {
          };
        }
        var segmentSection = this.getSectionById(139690087);
        if (!segmentSection) {
          logger("[fix-webm-duration] Segment section is missing");
          return false;
        }
        var infoSection = segmentSection.getSectionById(88713574);
        if (!infoSection) {
          logger("[fix-webm-duration] Info section is missing");
          return false;
        }
        var timeScaleSection = infoSection.getSectionById(710577);
        if (!timeScaleSection) {
          logger("[fix-webm-duration] TimecodeScale section is missing");
          return false;
        }
        var durationSection = infoSection.getSectionById(1161);
        if (durationSection) {
          if (durationSection.getValue() <= 0) {
            logger(`[fix-webm-duration] Duration section is present, but the value is ${durationSection.getValue()}`);
            durationSection.setValue(duration);
          } else {
            logger(`[fix-webm-duration] Duration section is present, and the value is ${durationSection.getValue()}`);
            return false;
          }
        } else {
          logger("[fix-webm-duration] Duration section is missing");
          durationSection = new WebmFloat("Duration", "Float");
          durationSection.setValue(duration);
          infoSection.data.push({
            id: 1161,
            data: durationSection
          });
        }
        timeScaleSection.setValue(1e6);
        infoSection.updateByData();
        segmentSection.updateByData();
        this.updateByData();
        return true;
      };
      WebmFile.prototype.toBlob = function(mimeType) {
        return new Blob([this.source.buffer], { type: mimeType || "video/webm" });
      };
      function fixWebmDuration2(blob, duration, callback, options) {
        if (typeof callback === "object") {
          options = callback;
          callback = void 0;
        }
        if (!callback) {
          return new Promise(function(resolve) {
            fixWebmDuration2(blob, duration, resolve, options);
          });
        }
        try {
          var reader = new FileReader();
          reader.onloadend = function() {
            try {
              var file = new WebmFile(new Uint8Array(reader.result));
              if (file.fixDuration(duration, options)) {
                blob = file.toBlob(blob.type);
              }
            } catch (ex) {
            }
            callback(blob);
          };
          reader.readAsArrayBuffer(blob);
        } catch (ex) {
          callback(blob);
        }
      }
      fixWebmDuration2.default = fixWebmDuration2;
      return fixWebmDuration2;
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AudioRecorderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var import_fix_webm_duration = __toESM(require_fix_webm_duration());
var DEFAULT_SETTINGS = {
  recordingsFolder: "Recordings",
  recordMicrophone: true,
  selectedMicrophoneId: "default",
  muteHotkey: "CommandOrControl+Shift+M"
  // Default global hotkey
};
var AudioRecorderPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.recorder = null;
    this.chunks = [];
    this.recordingStream = null;
    this.micStream = null;
    this.audioContext = null;
    this.micGainNode = null;
    this.isMicMuted = false;
    this.analyserNode = null;
    this.statusBarItem = null;
    this.activeFileAtStart = null;
    this.controlWindow = null;
    // BrowserWindow
    this.processorNode = null;
    this.muteGainNode = null;
    this.animationIntervalId = null;
    this.electron = null;
    // Electron reference
    this.startTime = 0;
  }
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon(
      "microphone",
      "Start/Stop Recording",
      (evt) => {
        this.toggleRecording();
      }
    );
    ribbonIconEl.addClass("audio-recorder-ribbon-class");
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("");
    this.addCommand({
      id: "start-stop-recording",
      name: "Start/Stop Recording",
      callback: () => {
        this.toggleRecording();
      }
    });
    this.addCommand({
      id: "toggle-mic-mute",
      name: "Toggle Microphone Mute",
      callback: () => {
        this.toggleMute();
      }
    });
    this.addSettingTab(new AudioRecorderSettingTab(this.app, this));
  }
  onunload() {
    this.stopRecording();
    this.unregisterGlobalHotkey();
  }
  async toggleRecording() {
    if (this.recorder && this.recorder.state === "recording") {
      this.stopRecording();
    } else {
      this.startRecording();
    }
  }
  toggleMute() {
    if (!this.recorder || this.recorder.state !== "recording") {
      new import_obsidian.Notice("No active recording to mute/unmute microphone.");
      return;
    }
    if (!this.micGainNode) {
      new import_obsidian.Notice("Microphone is not being recorded.");
      return;
    }
    this.isMicMuted = !this.isMicMuted;
    this.micGainNode.gain.value = this.isMicMuted ? 0 : 1;
    if (this.controlWindow && !this.controlWindow.isDestroyed()) {
      this.controlWindow.webContents.send("toggle-mute-state", this.isMicMuted);
    }
    new import_obsidian.Notice(this.isMicMuted ? "Microphone muted" : "Microphone unmuted");
  }
  async startRecording() {
    var _a;
    try {
      this.activeFileAtStart = this.app.workspace.getActiveFile();
      const electron = require("electron");
      this.electron = electron;
      let desktopCapturer = electron.desktopCapturer;
      let remote = electron.remote;
      if (!desktopCapturer && remote) {
        desktopCapturer = remote.desktopCapturer;
      }
      if (!desktopCapturer) {
        new import_obsidian.Notice("Error: desktopCapturer API is not available.");
        return;
      }
      this.registerGlobalHotkey();
      const sources = await desktopCapturer.getSources({ types: ["screen"] });
      if (sources.length === 0) {
        new import_obsidian.Notice("No screen sources found.");
        return;
      }
      const source = sources[0];
      const systemStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: source.id
          }
        },
        video: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: source.id
          }
        }
      });
      const systemAudioTracks = systemStream.getAudioTracks();
      if (systemAudioTracks.length === 0) {
        new import_obsidian.Notice(
          "No system audio track captured. Ensure you are on Windows or have system audio setup."
        );
      }
      this.recordingStream = systemStream;
      if (this.settings.recordMicrophone) {
        try {
          const constraints = { audio: true };
          if (this.settings.selectedMicrophoneId && this.settings.selectedMicrophoneId !== "default") {
            constraints.audio = {
              deviceId: { exact: this.settings.selectedMicrophoneId }
            };
          }
          this.micStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (micErr) {
          console.error("Error capturing microphone:", micErr);
          new import_obsidian.Notice(
            "Failed to capture microphone. Recording system audio only."
          );
        }
      }
      let finalStream;
      this.audioContext = new AudioContext();
      const destination = this.audioContext.createMediaStreamDestination();
      const masterGain = this.audioContext.createGain();
      masterGain.connect(destination);
      this.analyserNode = this.audioContext.createAnalyser();
      this.analyserNode.fftSize = 128;
      this.analyserNode.smoothingTimeConstant = 0.5;
      masterGain.connect(this.analyserNode);
      if (systemAudioTracks.length > 0) {
        const systemSource = this.audioContext.createMediaStreamSource(systemStream);
        systemSource.connect(masterGain);
      }
      if (this.micStream) {
        const micSource = this.audioContext.createMediaStreamSource(
          this.micStream
        );
        this.micGainNode = this.audioContext.createGain();
        this.micGainNode.gain.value = 1;
        micSource.connect(this.micGainNode);
        this.micGainNode.connect(masterGain);
      }
      finalStream = destination.stream;
      if (finalStream.getAudioTracks().length === 0) {
        new import_obsidian.Notice("No audio tracks available to record.");
        this.stopRecordingStreams();
        return;
      }
      this.recorder = new MediaRecorder(finalStream, {
        mimeType: "audio/webm"
      });
      this.chunks = [];
      this.recorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          this.chunks.push(e.data);
        }
      };
      this.recorder.onstop = async () => {
        var _a2;
        const blob = new Blob(this.chunks, { type: "audio/webm" });
        await this.saveRecording(blob);
        this.stopRecordingStreams();
        (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText("");
        new import_obsidian.Notice("Recording saved.");
        this.closeControlWindow();
      };
      this.recorder.start();
      this.startTime = Date.now();
      (_a = this.statusBarItem) == null ? void 0 : _a.setText("Recording...");
      new import_obsidian.Notice("Recording started.");
      this.openControlWindow(electron);
      this.startAudioVisualization();
    } catch (err) {
      console.error("Error starting recording:", err);
      new import_obsidian.Notice("Failed to start recording. See console for details.");
      this.stopRecordingStreams();
    }
  }
  openControlWindow(electron) {
    const remote = electron.remote || electron;
    const BrowserWindow = remote.BrowserWindow;
    const ipcMain = remote.ipcMain;
    const { width, height } = remote.screen.getPrimaryDisplay().workAreaSize;
    this.controlWindow = new BrowserWindow({
      width: 320,
      height: 110,
      frame: false,
      transparent: true,
      backgroundColor: "#00000000",
      // Force transparency
      hasShadow: false,
      // Disable native shadow to prevent black corners
      alwaysOnTop: true,
      resizable: false,
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        backgroundThrottling: false
        // Prevent throttling when in background
      },
      x: Math.floor(width / 2 - 160),
      y: height - 110
    });
    const pluginDir = this.app.vault.adapter.basePath + "/" + this.manifest.dir;
    const htmlPath = path.join(pluginDir, "control-window.html");
    this.controlWindow.loadFile(htmlPath);
    this.controlWindow.webContents.on("did-finish-load", () => {
      const accentColor = getComputedStyle(document.body).getPropertyValue(
        "--interactive-accent"
      ) || "#7c3aed";
      this.controlWindow.webContents.send("set-accent-color", accentColor);
    });
    const onMuteMic = () => {
      if (this.micGainNode) {
        this.micGainNode.gain.value = 0;
        this.isMicMuted = true;
      }
    };
    const onUnmuteMic = () => {
      if (this.micGainNode) {
        this.micGainNode.gain.value = 1;
        this.isMicMuted = false;
      }
    };
    const onStopRecording = () => {
      this.stopRecording();
    };
    ipcMain.on("mute-mic", onMuteMic);
    ipcMain.on("unmute-mic", onUnmuteMic);
    ipcMain.on("stop-recording", onStopRecording);
    this.controlWindow.on("closed", () => {
      ipcMain.removeListener("mute-mic", onMuteMic);
      ipcMain.removeListener("unmute-mic", onUnmuteMic);
      ipcMain.removeListener("stop-recording", onStopRecording);
      this.controlWindow = null;
    });
  }
  closeControlWindow() {
    if (this.controlWindow) {
      this.controlWindow.close();
      this.controlWindow = null;
    }
    if (this.processorNode) {
      this.processorNode.disconnect();
      this.processorNode = null;
    }
    if (this.muteGainNode) {
      this.muteGainNode.disconnect();
      this.muteGainNode = null;
    }
  }
  startAudioVisualization() {
    if (!this.analyserNode || !this.controlWindow || !this.audioContext)
      return;
    const dataArray = new Uint8Array(this.analyserNode.frequencyBinCount);
    this.processorNode = this.audioContext.createScriptProcessor(2048, 1, 1);
    this.muteGainNode = this.audioContext.createGain();
    this.muteGainNode.gain.value = 0;
    this.analyserNode.connect(this.processorNode);
    this.processorNode.connect(this.muteGainNode);
    this.muteGainNode.connect(this.audioContext.destination);
    this.processorNode.onaudioprocess = () => {
      if (!this.analyserNode || !this.controlWindow) {
        if (this.processorNode) {
          this.processorNode.disconnect();
          this.processorNode = null;
        }
        return;
      }
      this.analyserNode.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const average = sum / dataArray.length / 255;
      try {
        if (!this.controlWindow.isDestroyed()) {
          this.controlWindow.webContents.send("audio-level", average);
        }
      } catch (err) {
      }
    };
  }
  stopRecording() {
    if (this.recorder && this.recorder.state === "recording") {
      this.recorder.stop();
    }
    this.unregisterGlobalHotkey();
  }
  stopRecordingStreams() {
    if (this.recordingStream) {
      this.recordingStream.getTracks().forEach((track) => track.stop());
      this.recordingStream = null;
    }
    if (this.micStream) {
      this.micStream.getTracks().forEach((track) => track.stop());
      this.micStream = null;
    }
    if (this.processorNode) {
      this.processorNode.disconnect();
      this.processorNode = null;
    }
    if (this.muteGainNode) {
      this.muteGainNode.disconnect();
      this.muteGainNode = null;
    }
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
    this.recorder = null;
  }
  registerGlobalHotkey() {
    if (!this.electron || !this.settings.muteHotkey)
      return;
    try {
      const remote = this.electron.remote || this.electron;
      const { globalShortcut } = remote;
      this.unregisterGlobalHotkey();
      const registered = globalShortcut.register(
        this.settings.muteHotkey,
        () => {
          this.toggleMute();
        }
      );
      if (!registered) {
        console.warn(
          `Failed to register global hotkey: ${this.settings.muteHotkey}`
        );
      }
    } catch (err) {
      console.error("Error registering global hotkey:", err);
    }
  }
  unregisterGlobalHotkey() {
    if (!this.electron || !this.settings.muteHotkey)
      return;
    try {
      const remote = this.electron.remote || this.electron;
      const { globalShortcut } = remote;
      if (globalShortcut.isRegistered(this.settings.muteHotkey)) {
        globalShortcut.unregister(this.settings.muteHotkey);
      }
    } catch (err) {
      console.error("Error unregistering global hotkey:", err);
    }
  }
  async saveRecording(blob) {
    const duration = Date.now() - this.startTime;
    const fixedBlob = await new Promise((resolve) => {
      (0, import_fix_webm_duration.default)(blob, duration, (fixed) => {
        resolve(fixed);
      });
    });
    const arrayBuffer = await fixedBlob.arrayBuffer();
    const buffer = new Uint8Array(arrayBuffer);
    const folderPath = this.settings.recordingsFolder;
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
    const now = new Date();
    const timestamp = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, "0")}-${now.getDate().toString().padStart(2, "0")} ${now.getHours().toString().padStart(2, "0")}.${now.getMinutes().toString().padStart(2, "0")}.${now.getSeconds().toString().padStart(2, "0")}`;
    const filename = `${folderPath}/Recording ${timestamp}.webm`;
    const file = await this.app.vault.createBinary(filename, buffer);
    if (this.activeFileAtStart) {
      const linkText = `
![[${file.path}]]
`;
      await this.app.vault.append(this.activeFileAtStart, linkText);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AudioRecorderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Audio Recorder" });
    new import_obsidian.Setting(containerEl).setName("Recordings Folder").setDesc("Folder to save audio recordings in").addText(
      (text) => text.setPlaceholder("Recordings").setValue(this.plugin.settings.recordingsFolder).onChange(async (value) => {
        this.plugin.settings.recordingsFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Record Microphone").setDesc("Record microphone audio along with system audio.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.recordMicrophone).onChange(async (value) => {
        this.plugin.settings.recordMicrophone = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Microphone Source").setDesc("Select the microphone to record.").addDropdown(async (dropdown) => {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter((d) => d.kind === "audioinput");
      audioInputs.forEach((device) => {
        dropdown.addOption(
          device.deviceId,
          device.label || `Microphone ${device.deviceId}`
        );
      });
      dropdown.setValue(this.plugin.settings.selectedMicrophoneId);
      dropdown.onChange(async (value) => {
        this.plugin.settings.selectedMicrophoneId = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Hotkeys" });
    new import_obsidian.Setting(containerEl).setName("Global Mute Hotkey").setDesc(
      "Set a system-wide hotkey to toggle microphone muting (works even when Obsidian isn't focused). Uses Electron's accelerator format. Examples: 'CommandOrControl+Shift+M', 'Alt+M', 'Ctrl+Shift+Space'. Changes take effect when starting a new recording."
    ).addText(
      (text) => text.setPlaceholder("CommandOrControl+Shift+M").setValue(this.plugin.settings.muteHotkey).onChange(async (value) => {
        this.plugin.settings.muteHotkey = value;
        await this.plugin.saveSettings();
      })
    );
    const hotkeyDesc = containerEl.createDiv();
    hotkeyDesc.addClass("setting-item-description");
    hotkeyDesc.setText(
      "You can also use Obsidian's built-in hotkeys (Settings \u2192 Hotkeys \u2192 'Toggle Microphone Mute'), but those only work when Obsidian is focused."
    );
    hotkeyDesc.style.marginBottom = "1em";
  }
};
