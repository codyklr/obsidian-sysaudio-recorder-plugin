/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/fix-webm-duration/fix-webm-duration.js
var require_fix_webm_duration = __commonJS({
  "node_modules/fix-webm-duration/fix-webm-duration.js"(exports, module2) {
    (function(name, definition) {
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = definition();
      } else {
        window.ysFixWebmDuration = definition();
      }
    })("fix-webm-duration", function() {
      var sections = {
        172351395: { name: "EBML", type: "Container" },
        646: { name: "EBMLVersion", type: "Uint" },
        759: { name: "EBMLReadVersion", type: "Uint" },
        754: { name: "EBMLMaxIDLength", type: "Uint" },
        755: { name: "EBMLMaxSizeLength", type: "Uint" },
        642: { name: "DocType", type: "String" },
        647: { name: "DocTypeVersion", type: "Uint" },
        645: { name: "DocTypeReadVersion", type: "Uint" },
        108: { name: "Void", type: "Binary" },
        63: { name: "CRC-32", type: "Binary" },
        190023271: { name: "SignatureSlot", type: "Container" },
        16010: { name: "SignatureAlgo", type: "Uint" },
        16026: { name: "SignatureHash", type: "Uint" },
        16037: { name: "SignaturePublicKey", type: "Binary" },
        16053: { name: "Signature", type: "Binary" },
        15963: { name: "SignatureElements", type: "Container" },
        15995: { name: "SignatureElementList", type: "Container" },
        9522: { name: "SignedElement", type: "Binary" },
        139690087: { name: "Segment", type: "Container" },
        21863284: { name: "SeekHead", type: "Container" },
        3515: { name: "Seek", type: "Container" },
        5035: { name: "SeekID", type: "Binary" },
        5036: { name: "SeekPosition", type: "Uint" },
        88713574: { name: "Info", type: "Container" },
        13220: { name: "SegmentUID", type: "Binary" },
        13188: { name: "SegmentFilename", type: "String" },
        1882403: { name: "PrevUID", type: "Binary" },
        1868715: { name: "PrevFilename", type: "String" },
        2013475: { name: "NextUID", type: "Binary" },
        1999803: { name: "NextFilename", type: "String" },
        1092: { name: "SegmentFamily", type: "Binary" },
        10532: { name: "ChapterTranslate", type: "Container" },
        10748: { name: "ChapterTranslateEditionUID", type: "Uint" },
        10687: { name: "ChapterTranslateCodec", type: "Uint" },
        10661: { name: "ChapterTranslateID", type: "Binary" },
        710577: { name: "TimecodeScale", type: "Uint" },
        1161: { name: "Duration", type: "Float" },
        1121: { name: "DateUTC", type: "Date" },
        15273: { name: "Title", type: "String" },
        3456: { name: "MuxingApp", type: "String" },
        5953: { name: "WritingApp", type: "String" },
        // 0xf43b675: { name: 'Cluster', type: 'Container' },
        103: { name: "Timecode", type: "Uint" },
        6228: { name: "SilentTracks", type: "Container" },
        6359: { name: "SilentTrackNumber", type: "Uint" },
        39: { name: "Position", type: "Uint" },
        43: { name: "PrevSize", type: "Uint" },
        35: { name: "SimpleBlock", type: "Binary" },
        32: { name: "BlockGroup", type: "Container" },
        33: { name: "Block", type: "Binary" },
        34: { name: "BlockVirtual", type: "Binary" },
        13729: { name: "BlockAdditions", type: "Container" },
        38: { name: "BlockMore", type: "Container" },
        110: { name: "BlockAddID", type: "Uint" },
        37: { name: "BlockAdditional", type: "Binary" },
        27: { name: "BlockDuration", type: "Uint" },
        122: { name: "ReferencePriority", type: "Uint" },
        123: { name: "ReferenceBlock", type: "Int" },
        125: { name: "ReferenceVirtual", type: "Int" },
        36: { name: "CodecState", type: "Binary" },
        13730: { name: "DiscardPadding", type: "Int" },
        14: { name: "Slices", type: "Container" },
        104: { name: "TimeSlice", type: "Container" },
        76: { name: "LaceNumber", type: "Uint" },
        77: { name: "FrameNumber", type: "Uint" },
        75: { name: "BlockAdditionID", type: "Uint" },
        78: { name: "Delay", type: "Uint" },
        79: { name: "SliceDuration", type: "Uint" },
        72: { name: "ReferenceFrame", type: "Container" },
        73: { name: "ReferenceOffset", type: "Uint" },
        74: { name: "ReferenceTimeCode", type: "Uint" },
        47: { name: "EncryptedBlock", type: "Binary" },
        106212971: { name: "Tracks", type: "Container" },
        46: { name: "TrackEntry", type: "Container" },
        87: { name: "TrackNumber", type: "Uint" },
        13253: { name: "TrackUID", type: "Uint" },
        3: { name: "TrackType", type: "Uint" },
        57: { name: "FlagEnabled", type: "Uint" },
        8: { name: "FlagDefault", type: "Uint" },
        5546: { name: "FlagForced", type: "Uint" },
        28: { name: "FlagLacing", type: "Uint" },
        11751: { name: "MinCache", type: "Uint" },
        11768: { name: "MaxCache", type: "Uint" },
        254851: { name: "DefaultDuration", type: "Uint" },
        216698: { name: "DefaultDecodedFieldDuration", type: "Uint" },
        209231: { name: "TrackTimecodeScale", type: "Float" },
        4991: { name: "TrackOffset", type: "Int" },
        5614: { name: "MaxBlockAdditionID", type: "Uint" },
        4974: { name: "Name", type: "String" },
        177564: { name: "Language", type: "String" },
        6: { name: "CodecID", type: "String" },
        9122: { name: "CodecPrivate", type: "Binary" },
        362120: { name: "CodecName", type: "String" },
        13382: { name: "AttachmentLink", type: "Uint" },
        1742487: { name: "CodecSettings", type: "String" },
        1785920: { name: "CodecInfoURL", type: "String" },
        438848: { name: "CodecDownloadURL", type: "String" },
        42: { name: "CodecDecodeAll", type: "Uint" },
        12203: { name: "TrackOverlay", type: "Uint" },
        5802: { name: "CodecDelay", type: "Uint" },
        5819: { name: "SeekPreRoll", type: "Uint" },
        9764: { name: "TrackTranslate", type: "Container" },
        9980: { name: "TrackTranslateEditionUID", type: "Uint" },
        9919: { name: "TrackTranslateCodec", type: "Uint" },
        9893: { name: "TrackTranslateTrackID", type: "Binary" },
        96: { name: "Video", type: "Container" },
        26: { name: "FlagInterlaced", type: "Uint" },
        5048: { name: "StereoMode", type: "Uint" },
        5056: { name: "AlphaMode", type: "Uint" },
        5049: { name: "OldStereoMode", type: "Uint" },
        48: { name: "PixelWidth", type: "Uint" },
        58: { name: "PixelHeight", type: "Uint" },
        5290: { name: "PixelCropBottom", type: "Uint" },
        5307: { name: "PixelCropTop", type: "Uint" },
        5324: { name: "PixelCropLeft", type: "Uint" },
        5341: { name: "PixelCropRight", type: "Uint" },
        5296: { name: "DisplayWidth", type: "Uint" },
        5306: { name: "DisplayHeight", type: "Uint" },
        5298: { name: "DisplayUnit", type: "Uint" },
        5299: { name: "AspectRatioType", type: "Uint" },
        963876: { name: "ColourSpace", type: "Binary" },
        1029411: { name: "GammaValue", type: "Float" },
        230371: { name: "FrameRate", type: "Float" },
        97: { name: "Audio", type: "Container" },
        53: { name: "SamplingFrequency", type: "Float" },
        14517: { name: "OutputSamplingFrequency", type: "Float" },
        31: { name: "Channels", type: "Uint" },
        15739: { name: "ChannelPositions", type: "Binary" },
        8804: { name: "BitDepth", type: "Uint" },
        98: { name: "TrackOperation", type: "Container" },
        99: { name: "TrackCombinePlanes", type: "Container" },
        100: { name: "TrackPlane", type: "Container" },
        101: { name: "TrackPlaneUID", type: "Uint" },
        102: { name: "TrackPlaneType", type: "Uint" },
        105: { name: "TrackJoinBlocks", type: "Container" },
        109: { name: "TrackJoinUID", type: "Uint" },
        64: { name: "TrickTrackUID", type: "Uint" },
        65: { name: "TrickTrackSegmentUID", type: "Binary" },
        70: { name: "TrickTrackFlag", type: "Uint" },
        71: { name: "TrickMasterTrackUID", type: "Uint" },
        68: { name: "TrickMasterTrackSegmentUID", type: "Binary" },
        11648: { name: "ContentEncodings", type: "Container" },
        8768: { name: "ContentEncoding", type: "Container" },
        4145: { name: "ContentEncodingOrder", type: "Uint" },
        4146: { name: "ContentEncodingScope", type: "Uint" },
        4147: { name: "ContentEncodingType", type: "Uint" },
        4148: { name: "ContentCompression", type: "Container" },
        596: { name: "ContentCompAlgo", type: "Uint" },
        597: { name: "ContentCompSettings", type: "Binary" },
        4149: { name: "ContentEncryption", type: "Container" },
        2017: { name: "ContentEncAlgo", type: "Uint" },
        2018: { name: "ContentEncKeyID", type: "Binary" },
        2019: { name: "ContentSignature", type: "Binary" },
        2020: { name: "ContentSigKeyID", type: "Binary" },
        2021: { name: "ContentSigAlgo", type: "Uint" },
        2022: { name: "ContentSigHashAlgo", type: "Uint" },
        206814059: { name: "Cues", type: "Container" },
        59: { name: "CuePoint", type: "Container" },
        51: { name: "CueTime", type: "Uint" },
        55: { name: "CueTrackPositions", type: "Container" },
        119: { name: "CueTrack", type: "Uint" },
        113: { name: "CueClusterPosition", type: "Uint" },
        112: { name: "CueRelativePosition", type: "Uint" },
        50: { name: "CueDuration", type: "Uint" },
        4984: { name: "CueBlockNumber", type: "Uint" },
        106: { name: "CueCodecState", type: "Uint" },
        91: { name: "CueReference", type: "Container" },
        22: { name: "CueRefTime", type: "Uint" },
        23: { name: "CueRefCluster", type: "Uint" },
        4959: { name: "CueRefNumber", type: "Uint" },
        107: { name: "CueRefCodecState", type: "Uint" },
        155296873: { name: "Attachments", type: "Container" },
        8615: { name: "AttachedFile", type: "Container" },
        1662: { name: "FileDescription", type: "String" },
        1646: { name: "FileName", type: "String" },
        1632: { name: "FileMimeType", type: "String" },
        1628: { name: "FileData", type: "Binary" },
        1710: { name: "FileUID", type: "Uint" },
        1653: { name: "FileReferral", type: "Binary" },
        1633: { name: "FileUsedStartTime", type: "Uint" },
        1634: { name: "FileUsedEndTime", type: "Uint" },
        4433776: { name: "Chapters", type: "Container" },
        1465: { name: "EditionEntry", type: "Container" },
        1468: { name: "EditionUID", type: "Uint" },
        1469: { name: "EditionFlagHidden", type: "Uint" },
        1499: { name: "EditionFlagDefault", type: "Uint" },
        1501: { name: "EditionFlagOrdered", type: "Uint" },
        54: { name: "ChapterAtom", type: "Container" },
        13252: { name: "ChapterUID", type: "Uint" },
        5716: { name: "ChapterStringUID", type: "String" },
        17: { name: "ChapterTimeStart", type: "Uint" },
        18: { name: "ChapterTimeEnd", type: "Uint" },
        24: { name: "ChapterFlagHidden", type: "Uint" },
        1432: { name: "ChapterFlagEnabled", type: "Uint" },
        11879: { name: "ChapterSegmentUID", type: "Binary" },
        11964: { name: "ChapterSegmentEditionUID", type: "Uint" },
        9155: { name: "ChapterPhysicalEquiv", type: "Uint" },
        15: { name: "ChapterTrack", type: "Container" },
        9: { name: "ChapterTrackNumber", type: "Uint" },
        0: { name: "ChapterDisplay", type: "Container" },
        5: { name: "ChapString", type: "String" },
        892: { name: "ChapLanguage", type: "String" },
        894: { name: "ChapCountry", type: "String" },
        10564: { name: "ChapProcess", type: "Container" },
        10581: { name: "ChapProcessCodecID", type: "Uint" },
        1293: { name: "ChapProcessPrivate", type: "Binary" },
        10513: { name: "ChapProcessCommand", type: "Container" },
        10530: { name: "ChapProcessTime", type: "Uint" },
        10547: { name: "ChapProcessData", type: "Binary" },
        39109479: { name: "Tags", type: "Container" },
        13171: { name: "Tag", type: "Container" },
        9152: { name: "Targets", type: "Container" },
        10442: { name: "TargetTypeValue", type: "Uint" },
        9162: { name: "TargetType", type: "String" },
        9157: { name: "TagTrackUID", type: "Uint" },
        9161: { name: "TagEditionUID", type: "Uint" },
        9156: { name: "TagChapterUID", type: "Uint" },
        9158: { name: "TagAttachmentUID", type: "Uint" },
        10184: { name: "SimpleTag", type: "Container" },
        1443: { name: "TagName", type: "String" },
        1146: { name: "TagLanguage", type: "String" },
        1156: { name: "TagDefault", type: "Uint" },
        1159: { name: "TagString", type: "String" },
        1157: { name: "TagBinary", type: "Binary" }
      };
      function doInherit(newClass, baseClass) {
        newClass.prototype = Object.create(baseClass.prototype);
        newClass.prototype.constructor = newClass;
      }
      function WebmBase(name, type) {
        this.name = name || "Unknown";
        this.type = type || "Unknown";
      }
      WebmBase.prototype.updateBySource = function() {
      };
      WebmBase.prototype.setSource = function(source) {
        this.source = source;
        this.updateBySource();
      };
      WebmBase.prototype.updateByData = function() {
      };
      WebmBase.prototype.setData = function(data) {
        this.data = data;
        this.updateByData();
      };
      function WebmUint(name, type) {
        WebmBase.call(this, name, type || "Uint");
      }
      doInherit(WebmUint, WebmBase);
      function padHex(hex) {
        return hex.length % 2 === 1 ? "0" + hex : hex;
      }
      WebmUint.prototype.updateBySource = function() {
        this.data = "";
        for (var i = 0; i < this.source.length; i++) {
          var hex = this.source[i].toString(16);
          this.data += padHex(hex);
        }
      };
      WebmUint.prototype.updateByData = function() {
        var length = this.data.length / 2;
        this.source = new Uint8Array(length);
        for (var i = 0; i < length; i++) {
          var hex = this.data.substr(i * 2, 2);
          this.source[i] = parseInt(hex, 16);
        }
      };
      WebmUint.prototype.getValue = function() {
        return parseInt(this.data, 16);
      };
      WebmUint.prototype.setValue = function(value) {
        this.setData(padHex(value.toString(16)));
      };
      function WebmFloat(name, type) {
        WebmBase.call(this, name, type || "Float");
      }
      doInherit(WebmFloat, WebmBase);
      WebmFloat.prototype.getFloatArrayType = function() {
        return this.source && this.source.length === 4 ? Float32Array : Float64Array;
      };
      WebmFloat.prototype.updateBySource = function() {
        var byteArray = this.source.reverse();
        var floatArrayType = this.getFloatArrayType();
        var floatArray = new floatArrayType(byteArray.buffer);
        this.data = floatArray[0];
      };
      WebmFloat.prototype.updateByData = function() {
        var floatArrayType = this.getFloatArrayType();
        var floatArray = new floatArrayType([this.data]);
        var byteArray = new Uint8Array(floatArray.buffer);
        this.source = byteArray.reverse();
      };
      WebmFloat.prototype.getValue = function() {
        return this.data;
      };
      WebmFloat.prototype.setValue = function(value) {
        this.setData(value);
      };
      function WebmContainer(name, type) {
        WebmBase.call(this, name, type || "Container");
      }
      doInherit(WebmContainer, WebmBase);
      WebmContainer.prototype.readByte = function() {
        return this.source[this.offset++];
      };
      WebmContainer.prototype.readUint = function() {
        var firstByte = this.readByte();
        var bytes = 8 - firstByte.toString(2).length;
        var value = firstByte - (1 << 7 - bytes);
        for (var i = 0; i < bytes; i++) {
          value *= 256;
          value += this.readByte();
        }
        return value;
      };
      WebmContainer.prototype.updateBySource = function() {
        this.data = [];
        for (this.offset = 0; this.offset < this.source.length; this.offset = end) {
          var id = this.readUint();
          var len = this.readUint();
          var end = Math.min(this.offset + len, this.source.length);
          var data = this.source.slice(this.offset, end);
          var info = sections[id] || { name: "Unknown", type: "Unknown" };
          var ctr = WebmBase;
          switch (info.type) {
            case "Container":
              ctr = WebmContainer;
              break;
            case "Uint":
              ctr = WebmUint;
              break;
            case "Float":
              ctr = WebmFloat;
              break;
          }
          var section = new ctr(info.name, info.type);
          section.setSource(data);
          this.data.push({
            id,
            idHex: id.toString(16),
            data: section
          });
        }
      };
      WebmContainer.prototype.writeUint = function(x, draft) {
        for (var bytes = 1, flag = 128; x >= flag && bytes < 8; bytes++, flag *= 128) {
        }
        if (!draft) {
          var value = flag + x;
          for (var i = bytes - 1; i >= 0; i--) {
            var c = value % 256;
            this.source[this.offset + i] = c;
            value = (value - c) / 256;
          }
        }
        this.offset += bytes;
      };
      WebmContainer.prototype.writeSections = function(draft) {
        this.offset = 0;
        for (var i = 0; i < this.data.length; i++) {
          var section = this.data[i], content = section.data.source, contentLength = content.length;
          this.writeUint(section.id, draft);
          this.writeUint(contentLength, draft);
          if (!draft) {
            this.source.set(content, this.offset);
          }
          this.offset += contentLength;
        }
        return this.offset;
      };
      WebmContainer.prototype.updateByData = function() {
        var length = this.writeSections("draft");
        this.source = new Uint8Array(length);
        this.writeSections();
      };
      WebmContainer.prototype.getSectionById = function(id) {
        for (var i = 0; i < this.data.length; i++) {
          var section = this.data[i];
          if (section.id === id) {
            return section.data;
          }
        }
        return null;
      };
      function WebmFile(source) {
        WebmContainer.call(this, "File", "File");
        this.setSource(source);
      }
      doInherit(WebmFile, WebmContainer);
      WebmFile.prototype.fixDuration = function(duration, options) {
        var logger = options && options.logger;
        if (logger === void 0) {
          logger = function(message) {
            console.log(message);
          };
        } else if (!logger) {
          logger = function() {
          };
        }
        var segmentSection = this.getSectionById(139690087);
        if (!segmentSection) {
          logger("[fix-webm-duration] Segment section is missing");
          return false;
        }
        var infoSection = segmentSection.getSectionById(88713574);
        if (!infoSection) {
          logger("[fix-webm-duration] Info section is missing");
          return false;
        }
        var timeScaleSection = infoSection.getSectionById(710577);
        if (!timeScaleSection) {
          logger("[fix-webm-duration] TimecodeScale section is missing");
          return false;
        }
        var durationSection = infoSection.getSectionById(1161);
        if (durationSection) {
          if (durationSection.getValue() <= 0) {
            logger(`[fix-webm-duration] Duration section is present, but the value is ${durationSection.getValue()}`);
            durationSection.setValue(duration);
          } else {
            logger(`[fix-webm-duration] Duration section is present, and the value is ${durationSection.getValue()}`);
            return false;
          }
        } else {
          logger("[fix-webm-duration] Duration section is missing");
          durationSection = new WebmFloat("Duration", "Float");
          durationSection.setValue(duration);
          infoSection.data.push({
            id: 1161,
            data: durationSection
          });
        }
        timeScaleSection.setValue(1e6);
        infoSection.updateByData();
        segmentSection.updateByData();
        this.updateByData();
        return true;
      };
      WebmFile.prototype.toBlob = function(mimeType) {
        return new Blob([this.source.buffer], { type: mimeType || "video/webm" });
      };
      function fixWebmDuration2(blob, duration, callback, options) {
        if (typeof callback === "object") {
          options = callback;
          callback = void 0;
        }
        if (!callback) {
          return new Promise(function(resolve) {
            fixWebmDuration2(blob, duration, resolve, options);
          });
        }
        try {
          var reader = new FileReader();
          reader.onloadend = function() {
            try {
              var file = new WebmFile(new Uint8Array(reader.result));
              if (file.fixDuration(duration, options)) {
                blob = file.toBlob(blob.type);
              }
            } catch (ex) {
            }
            callback(blob);
          };
          reader.readAsArrayBuffer(blob);
        } catch (ex) {
          callback(blob);
        }
      }
      fixWebmDuration2.default = fixWebmDuration2;
      return fixWebmDuration2;
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AudioRecorderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var import_fix_webm_duration = __toESM(require_fix_webm_duration());
var DEFAULT_SETTINGS = {
  recordingsFolder: "Recordings",
  recordMicrophone: true,
  selectedMicrophoneId: "default",
  muteHotkey: "CommandOrControl+Shift+M",
  // Default global hotkey
  outputFormat: "webm",
  enableTranscription: false,
  transcriptionMethod: "local",
  whisperModel: "base.en",
  whisperApiKey: "",
  whisperCppPath: ""
};
var AudioRecorderPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.recorder = null;
    this.chunks = [];
    this.recordingStream = null;
    this.micStream = null;
    this.audioContext = null;
    this.micGainNode = null;
    this.isMicMuted = false;
    this.analyserNode = null;
    this.statusBarItem = null;
    this.activeFileAtStart = null;
    this.controlWindow = null;
    // BrowserWindow
    this.processorNode = null;
    this.muteGainNode = null;
    this.animationIntervalId = null;
    this.electron = null;
    // Electron reference
    this.startTime = 0;
    // Audio properties
    this.sampleRate = 44100;
    this.numChannels = 2;
    // Transcription properties
    this.isTranscribing = false;
    this.transcriptionProcessor = null;
    this.transcriptionBuffer = [];
    this.transcriptionChunkIndex = 0;
    this.transcriptionText = "";
    // Accumulated transcription text
    this.transcriptionQueue = [];
    this.isProcessingQueue = false;
    this.lastTranscriptionText = "";
  }
  // For deduplication
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon(
      "microphone",
      "Start/Stop Recording",
      (evt) => {
        this.toggleRecording();
      }
    );
    ribbonIconEl.addClass("audio-recorder-ribbon-class");
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("");
    this.addCommand({
      id: "start-stop-recording",
      name: "Start/Stop Recording",
      callback: () => {
        this.toggleRecording();
      }
    });
    this.addCommand({
      id: "toggle-mic-mute",
      name: "Toggle Microphone Mute",
      callback: () => {
        this.toggleMute();
      }
    });
    this.addCommand({
      id: "show-control-window",
      name: "Show Recording Control Window",
      callback: () => {
        this.showControlWindow();
      }
    });
    this.addSettingTab(new AudioRecorderSettingTab(this.app, this));
  }
  onunload() {
    this.stopRecording();
    this.unregisterGlobalHotkey();
  }
  async toggleRecording() {
    if (this.recorder && this.recorder.state === "recording") {
      this.stopRecording();
    } else {
      this.startRecording();
    }
  }
  toggleMute() {
    const isRecording = this.recorder && this.recorder.state === "recording";
    if (!isRecording) {
      new import_obsidian.Notice("No active recording to mute/unmute microphone.");
      return;
    }
    if (!this.micGainNode) {
      new import_obsidian.Notice("Microphone is not being recorded.");
      return;
    }
    this.isMicMuted = !this.isMicMuted;
    this.micGainNode.gain.value = this.isMicMuted ? 0 : 1;
    if (this.controlWindow && !this.controlWindow.isDestroyed()) {
      this.controlWindow.webContents.send("toggle-mute-state", this.isMicMuted);
    }
    new import_obsidian.Notice(this.isMicMuted ? "Microphone muted" : "Microphone unmuted");
  }
  async startRecording() {
    try {
      this.activeFileAtStart = this.app.workspace.getActiveFile();
      const electron = require("electron");
      this.electron = electron;
      let desktopCapturer = electron.desktopCapturer;
      let remote = electron.remote;
      if (!desktopCapturer && remote) {
        desktopCapturer = remote.desktopCapturer;
      }
      if (!desktopCapturer) {
        new import_obsidian.Notice("Error: desktopCapturer API is not available.");
        return;
      }
      this.registerGlobalHotkey();
      const sources = await desktopCapturer.getSources({ types: ["screen"] });
      if (sources.length === 0) {
        new import_obsidian.Notice("No screen sources found.");
        return;
      }
      const source = sources[0];
      const systemStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: source.id
          }
        },
        video: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: source.id
          }
        }
      });
      const systemAudioTracks = systemStream.getAudioTracks();
      if (systemAudioTracks.length === 0) {
        new import_obsidian.Notice(
          "No system audio track captured. Ensure you are on Windows or have system audio setup."
        );
      }
      this.recordingStream = systemStream;
      if (this.settings.recordMicrophone) {
        try {
          const constraints = { audio: true };
          if (this.settings.selectedMicrophoneId && this.settings.selectedMicrophoneId !== "default") {
            constraints.audio = {
              deviceId: { exact: this.settings.selectedMicrophoneId }
            };
          }
          this.micStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (micErr) {
          console.error("Error capturing microphone:", micErr);
          new import_obsidian.Notice(
            "Failed to capture microphone. Recording system audio only."
          );
        }
      }
      let finalStream;
      this.audioContext = new AudioContext();
      this.sampleRate = this.audioContext.sampleRate;
      const destination = this.audioContext.createMediaStreamDestination();
      const masterGain = this.audioContext.createGain();
      masterGain.connect(destination);
      this.analyserNode = this.audioContext.createAnalyser();
      this.analyserNode.fftSize = 128;
      this.analyserNode.smoothingTimeConstant = 0.5;
      masterGain.connect(this.analyserNode);
      if (systemAudioTracks.length > 0) {
        const systemSource = this.audioContext.createMediaStreamSource(systemStream);
        systemSource.connect(masterGain);
      }
      if (this.micStream) {
        const micSource = this.audioContext.createMediaStreamSource(
          this.micStream
        );
        this.micGainNode = this.audioContext.createGain();
        this.micGainNode.gain.value = 1;
        micSource.connect(this.micGainNode);
        this.micGainNode.connect(masterGain);
      }
      finalStream = destination.stream;
      if (finalStream.getAudioTracks().length === 0) {
        new import_obsidian.Notice("No audio tracks available to record.");
        this.stopRecordingStreams();
        return;
      }
      this.recorder = new MediaRecorder(finalStream, {
        mimeType: "audio/webm"
      });
      this.chunks = [];
      this.recorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          this.chunks.push(e.data);
        }
      };
      this.recorder.onstop = async () => {
        const webmBlob = new Blob(this.chunks, { type: "audio/webm" });
        let finalBlob;
        if (this.settings.outputFormat === "wav") {
          new import_obsidian.Notice("Converting to WAV...");
          finalBlob = await this.convertWebMToWAV(webmBlob);
        } else {
          finalBlob = webmBlob;
        }
        await this.saveRecording(finalBlob);
        this.stopRecordingStreams();
        this.statusBarItem?.setText("");
        new import_obsidian.Notice("Recording saved.");
        this.closeControlWindow();
      };
      this.recorder.start();
      this.startTime = Date.now();
      this.statusBarItem?.setText("Recording...");
      new import_obsidian.Notice("Recording started.");
      this.openControlWindow(electron);
      this.startAudioVisualization();
    } catch (err) {
      console.error("Error starting recording:", err);
      new import_obsidian.Notice("Failed to start recording. See console for details.");
      this.stopRecordingStreams();
    }
  }
  openControlWindow(electron) {
    const remote = electron.remote || electron;
    const BrowserWindow = remote.BrowserWindow;
    const ipcMain = remote.ipcMain;
    const { width, height } = remote.screen.getPrimaryDisplay().workAreaSize;
    this.controlWindow = new BrowserWindow({
      width: 320,
      height: 110,
      frame: false,
      transparent: true,
      backgroundColor: "#00000000",
      // Force transparency
      hasShadow: false,
      // Disable native shadow to prevent black corners
      alwaysOnTop: true,
      resizable: false,
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        backgroundThrottling: false
        // Prevent throttling when in background
      },
      x: Math.floor(width / 2 - 160),
      y: height - 110
    });
    const pluginDir = this.app.vault.adapter.basePath + "/" + this.manifest.dir;
    const htmlPath = path.join(pluginDir, "control-window.html");
    this.controlWindow.loadFile(htmlPath);
    this.controlWindow.webContents.on("did-finish-load", () => {
      const accentColor = getComputedStyle(document.body).getPropertyValue(
        "--interactive-accent"
      ) || "#7c3aed";
      this.controlWindow.webContents.send("set-accent-color", accentColor);
      this.controlWindow.webContents.send("transcription-settings", {
        enabled: this.settings.enableTranscription
      });
    });
    const onMuteMic = () => {
      if (this.micGainNode) {
        this.micGainNode.gain.value = 0;
        this.isMicMuted = true;
      }
    };
    const onUnmuteMic = () => {
      if (this.micGainNode) {
        this.micGainNode.gain.value = 1;
        this.isMicMuted = false;
      }
    };
    const onStopRecording = () => {
      this.stopRecording();
    };
    const onToggleTranscription = () => {
      this.toggleTranscription();
    };
    const onResizeControlWindow = (event, width2, height2) => {
      if (this.controlWindow && !this.controlWindow.isDestroyed()) {
        const currentBounds = this.controlWindow.getBounds();
        this.controlWindow.setBounds({
          x: currentBounds.x,
          y: currentBounds.y,
          // Keep Y position fixed
          width: width2,
          height: height2
        });
      }
    };
    ipcMain.on("mute-mic", onMuteMic);
    ipcMain.on("unmute-mic", onUnmuteMic);
    ipcMain.on("stop-recording", onStopRecording);
    ipcMain.on("toggle-transcription", onToggleTranscription);
    ipcMain.on("resize-control-window", onResizeControlWindow);
    this.controlWindow.on("blur", () => {
      if (this.controlWindow && !this.controlWindow.isDestroyed()) {
        this.controlWindow.setAlwaysOnTop(false);
        this.controlWindow.setAlwaysOnTop(true);
      }
    });
    this.controlWindow.on("focus", () => {
      if (this.controlWindow && !this.controlWindow.isDestroyed()) {
        this.controlWindow.show();
        this.controlWindow.focus();
      }
    });
    this.controlWindow.on("minimize", (event) => {
      event.preventDefault();
      if (this.controlWindow && !this.controlWindow.isDestroyed()) {
        this.controlWindow.restore();
        this.controlWindow.focus();
      }
    });
    this.controlWindow.on("closed", () => {
      ipcMain.removeListener("mute-mic", onMuteMic);
      ipcMain.removeListener("unmute-mic", onUnmuteMic);
      ipcMain.removeListener("stop-recording", onStopRecording);
      ipcMain.removeListener("toggle-transcription", onToggleTranscription);
      ipcMain.removeListener("resize-control-window", onResizeControlWindow);
      this.controlWindow = null;
    });
  }
  showControlWindow() {
    if (this.controlWindow && !this.controlWindow.isDestroyed()) {
      this.controlWindow.show();
      this.controlWindow.restore();
      this.controlWindow.focus();
      this.controlWindow.setAlwaysOnTop(true);
      new import_obsidian.Notice("Control window restored.");
    } else if (!this.recorder || this.recorder.state !== "recording") {
      new import_obsidian.Notice("No recording in progress.");
    }
  }
  closeControlWindow() {
    if (this.controlWindow) {
      this.controlWindow.close();
      this.controlWindow = null;
    }
    if (this.processorNode) {
      this.processorNode.disconnect();
      this.processorNode = null;
    }
    if (this.muteGainNode) {
      this.muteGainNode.disconnect();
      this.muteGainNode = null;
    }
  }
  startAudioVisualization() {
    if (!this.analyserNode || !this.controlWindow || !this.audioContext)
      return;
    const dataArray = new Uint8Array(this.analyserNode.frequencyBinCount);
    this.processorNode = this.audioContext.createScriptProcessor(2048, 1, 1);
    this.muteGainNode = this.audioContext.createGain();
    this.muteGainNode.gain.value = 0;
    this.analyserNode.connect(this.processorNode);
    this.processorNode.connect(this.muteGainNode);
    this.muteGainNode.connect(this.audioContext.destination);
    this.processorNode.onaudioprocess = () => {
      if (!this.analyserNode || !this.controlWindow) {
        if (this.processorNode) {
          this.processorNode.disconnect();
          this.processorNode = null;
        }
        return;
      }
      this.analyserNode.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const average = sum / dataArray.length / 255;
      try {
        if (!this.controlWindow.isDestroyed()) {
          this.controlWindow.webContents.send("audio-level", average);
        }
      } catch (err) {
      }
    };
  }
  toggleTranscription() {
    if (this.isTranscribing) {
      this.stopTranscription();
    } else {
      this.startTranscription();
    }
  }
  startTranscription() {
    if (!this.settings.enableTranscription || this.isTranscribing)
      return;
    if (!this.recorder || this.recorder.state !== "recording")
      return;
    this.isTranscribing = true;
    this.transcriptionBuffer = [];
    this.transcriptionChunkIndex = 0;
    this.transcriptionText = "";
    this.startLocalTranscription();
    if (this.controlWindow && !this.controlWindow.isDestroyed()) {
      this.controlWindow.webContents.send("transcription-started");
    }
  }
  async startLocalTranscription() {
    if (!this.audioContext)
      return;
    this.transcriptionProcessor = this.audioContext.createScriptProcessor(
      4096,
      this.numChannels,
      this.numChannels
    );
    if (this.analyserNode) {
      this.analyserNode.connect(this.transcriptionProcessor);
    }
    this.transcriptionProcessor.onaudioprocess = async (event) => {
      if (!this.isTranscribing)
        return;
      const channelData = [];
      for (let channel = 0; channel < event.inputBuffer.numberOfChannels; channel++) {
        channelData.push(event.inputBuffer.getChannelData(channel));
      }
      const monoData = new Float32Array(channelData[0].length);
      for (let i = 0; i < monoData.length; i++) {
        let sum = 0;
        for (let channel = 0; channel < channelData.length; channel++) {
          sum += channelData[channel][i];
        }
        monoData[i] = sum / channelData.length;
      }
      this.transcriptionBuffer.push(monoData);
      const totalSamples = this.transcriptionBuffer.reduce(
        (sum, arr) => sum + arr.length,
        0
      );
      const samplesPerChunk = this.sampleRate * 2;
      if (totalSamples >= samplesPerChunk) {
        const combined = new Float32Array(totalSamples);
        let offset = 0;
        for (const chunk of this.transcriptionBuffer) {
          combined.set(chunk, offset);
          offset += chunk.length;
        }
        const audioChunk = combined.slice(0, samplesPerChunk);
        const remaining = combined.slice(samplesPerChunk);
        this.transcriptionBuffer = remaining.length > 0 ? [remaining] : [];
        this.queueTranscription(audioChunk);
      }
    };
    const mutedGain = this.audioContext.createGain();
    mutedGain.gain.value = 0;
    this.transcriptionProcessor.connect(mutedGain);
    mutedGain.connect(this.audioContext.destination);
  }
  queueTranscription(audioData) {
    this.transcriptionQueue.push({
      audioData,
      timestamp: Date.now()
    });
    if (!this.isProcessingQueue) {
      this.processTranscriptionQueue();
    }
  }
  async processTranscriptionQueue() {
    if (this.isProcessingQueue)
      return;
    this.isProcessingQueue = true;
    while (this.transcriptionQueue.length > 0) {
      const item = this.transcriptionQueue.shift();
      if (item) {
        try {
          await this.transcribeAudioChunk(item.audioData);
        } catch (err) {
          console.error("Error processing transcription from queue:", err);
        }
      }
    }
    this.isProcessingQueue = false;
  }
  deduplicateTranscription(newText) {
    if (this.lastTranscriptionText && newText.toLowerCase().trim() === this.lastTranscriptionText.toLowerCase().trim()) {
      return "";
    }
    return newText;
  }
  async transcribeAudioChunk(audioData) {
    try {
      const fs = require("fs");
      const path2 = require("path");
      const os = require("os");
      const { spawn } = require("child_process");
      let whisperPath = this.settings.whisperCppPath;
      if (!whisperPath || !fs.existsSync(whisperPath)) {
        whisperPath = await this.findWhisperCpp();
      }
      if (!whisperPath) {
        throw new Error(
          "whisper.cpp not found. Please install it or set the path in settings."
        );
      }
      const pluginDir = path2.join(
        this.app.vault.adapter.getBasePath(),
        ".obsidian",
        "plugins",
        this.manifest.id
      );
      const tempDir = path2.join(pluginDir, "temp");
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }
      const chunkFileName = `chunk_${this.transcriptionChunkIndex++}`;
      const tempWavPath = path2.join(tempDir, `${chunkFileName}.wav`);
      const wavData = this.createWavFile(audioData, 16e3);
      fs.writeFileSync(tempWavPath, Buffer.from(wavData.buffer));
      const modelPath = path2.join(
        pluginDir,
        "models",
        `ggml-${this.settings.whisperModel}.bin`
      );
      if (!fs.existsSync(modelPath)) {
        throw new Error(
          `Whisper model (${this.settings.whisperModel}) not found. Please download it from the plugin settings (Settings \u2192 Audio Recorder \u2192 Download Model button).`
        );
      }
      const isPythonWhisper = whisperPath.includes("Python") || whisperPath.toLowerCase().includes("scripts");
      let whisperProcess;
      let outputTxtPath;
      let outputBasePath;
      if (isPythonWhisper) {
        throw new Error(
          "Detected OpenAI's Python Whisper. This plugin requires whisper.cpp. Please install whisper.cpp from https://github.com/ggerganov/whisper.cpp/releases"
        );
      } else {
        outputBasePath = path2.join(tempDir, chunkFileName);
        outputTxtPath = `${outputBasePath}.txt`;
        const args = [
          "-m",
          modelPath,
          "-f",
          tempWavPath,
          "-otxt",
          "-of",
          outputBasePath,
          "--no-timestamps",
          "-l",
          "en",
          "--no-prints",
          // Reduce output overhead
          "-t",
          "6",
          // Use 6 threads for faster processing
          "-p",
          "1"
          // Processors: 1 for fastest
        ];
        whisperProcess = spawn(whisperPath, args);
      }
      let stderr = "";
      let stdout = "";
      whisperProcess.stderr.on("data", (data) => {
        const text = data.toString();
        stderr += text;
      });
      whisperProcess.stdout.on("data", (data) => {
        const text = data.toString();
        stdout += text;
      });
      await new Promise((resolve, reject) => {
        whisperProcess.on("close", (code) => {
          if (stdout)
            console.log("Whisper stdout:", stdout);
          if (stderr)
            console.log("Whisper stderr:", stderr);
          if (code === 0) {
            resolve();
          } else {
            reject(
              new Error(
                `Whisper exited with code ${code}. Stderr: ${stderr || "none"}, Stdout: ${stdout || "none"}`
              )
            );
          }
        });
        whisperProcess.on("error", (err) => {
          console.error("Whisper process error:", err);
          reject(err);
        });
      });
      let actualOutputPath = outputTxtPath;
      const possiblePaths = [
        outputTxtPath,
        `${outputBasePath}.en.txt`
        // whisper may add .en before .txt
      ];
      for (const testPath of possiblePaths) {
        if (fs.existsSync(testPath)) {
          actualOutputPath = testPath;
          break;
        }
      }
      if (fs.existsSync(actualOutputPath)) {
        let transcriptionText = fs.readFileSync(actualOutputPath, "utf-8").trim();
        transcriptionText = transcriptionText.replace(/\[BLANK_AUDIO\]/g, "").trim();
        if (transcriptionText) {
          const newText = this.deduplicateTranscription(transcriptionText);
          if (newText) {
            this.transcriptionText += newText + " ";
            this.lastTranscriptionText = transcriptionText;
            if (this.controlWindow && !this.controlWindow.isDestroyed()) {
              this.controlWindow.webContents.send("transcription-update", {
                text: this.transcriptionText,
                // Send accumulated text
                interim: ""
              });
            } else {
              new import_obsidian.Notice(`Transcription: ${newText}`, 5e3);
            }
          }
        }
        outputTxtPath = actualOutputPath;
      } else {
        console.error(
          `Output file not found. Checked: ${possiblePaths.join(", ")}`
        );
        try {
          const filesInTemp = fs.readdirSync(tempDir);
          console.error(`Files in temp dir: ${filesInTemp.join(", ")}`);
        } catch (e) {
          console.error(`Could not list temp directory`);
        }
      }
      try {
        if (fs.existsSync(tempWavPath)) {
          fs.unlinkSync(tempWavPath);
        }
        if (fs.existsSync(outputTxtPath)) {
          fs.unlinkSync(outputTxtPath);
        }
      } catch (err) {
      }
    } catch (err) {
      console.error("Error transcribing audio chunk:", err);
      if (this.controlWindow && !this.controlWindow.isDestroyed()) {
        this.controlWindow.webContents.send(
          "transcription-error",
          err.message || "Transcription failed"
        );
      }
    }
  }
  async findWhisperCpp() {
    const fs = require("fs");
    const path2 = require("path");
    const { spawn } = require("child_process");
    const os = require("os");
    const platform = os.platform();
    const binDir = path2.join(
      this.app.vault.adapter.getBasePath(),
      ".obsidian",
      "plugins",
      this.manifest.id,
      "bin"
    );
    const localExecutableName = platform === "win32" ? "main.exe" : "main";
    const localExecutablePath = path2.join(binDir, localExecutableName);
    if (fs.existsSync(localExecutablePath)) {
      return localExecutablePath;
    }
    const commands = platform === "win32" ? ["whisper.exe", "main.exe", "whisper-cli.exe"] : ["whisper", "whisper.cpp", "main"];
    for (const cmd of commands) {
      try {
        const which = platform === "win32" ? "where" : "which";
        const result = await new Promise((resolve, reject) => {
          const proc = spawn(which, [cmd]);
          let output = "";
          proc.stdout.on("data", (data) => {
            output += data.toString();
          });
          proc.on("close", (code) => {
            if (code === 0 && output.trim()) {
              resolve(output.trim().split("\n")[0]);
            } else {
              reject();
            }
          });
        });
        return result;
      } catch (err) {
      }
    }
    return null;
  }
  async stopTranscription() {
    this.isTranscribing = false;
    if (this.transcriptionProcessor) {
      this.transcriptionProcessor.disconnect();
      this.transcriptionProcessor = null;
    }
    if (this.transcriptionQueue.length > 0) {
      new import_obsidian.Notice(
        `Processing remaining ${this.transcriptionQueue.length} transcription chunks...`
      );
      while (this.transcriptionQueue.length > 0 || this.isProcessingQueue) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      new import_obsidian.Notice("All transcription chunks processed!");
    }
    this.transcriptionBuffer = [];
    this.transcriptionQueue = [];
    this.lastTranscriptionText = "";
    if (this.controlWindow && !this.controlWindow.isDestroyed()) {
      this.controlWindow.webContents.send("transcription-stopped");
    }
  }
  async stopRecording() {
    if (this.isTranscribing) {
      await this.stopTranscription();
    }
    if (this.recorder && this.recorder.state === "recording") {
      this.recorder.stop();
    }
    this.unregisterGlobalHotkey();
  }
  async convertWebMToWAV(webmBlob) {
    const arrayBuffer = await webmBlob.arrayBuffer();
    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
    this.sampleRate = audioBuffer.sampleRate;
    this.numChannels = audioBuffer.numberOfChannels;
    const channels = [];
    for (let i = 0; i < this.numChannels; i++) {
      channels.push(audioBuffer.getChannelData(i));
    }
    let interleaved;
    if (this.numChannels === 2) {
      interleaved = this.interleave(channels[0], channels[1]);
    } else if (this.numChannels === 1) {
      interleaved = this.interleave(channels[0], channels[0]);
      this.numChannels = 2;
    } else {
      const left = new Float32Array(audioBuffer.length);
      const right = new Float32Array(audioBuffer.length);
      for (let i = 0; i < audioBuffer.length; i++) {
        left[i] = channels[0][i];
        right[i] = channels[Math.min(1, channels.length - 1)][i];
      }
      interleaved = this.interleave(left, right);
      this.numChannels = 2;
    }
    const wavData = this.writeWavHeader(interleaved);
    return new Blob([wavData], { type: "audio/wav" });
  }
  stopRecordingStreams() {
    if (this.recordingStream) {
      this.recordingStream.getTracks().forEach((track) => track.stop());
      this.recordingStream = null;
    }
    if (this.micStream) {
      this.micStream.getTracks().forEach((track) => track.stop());
      this.micStream = null;
    }
    if (this.processorNode) {
      this.processorNode.disconnect();
      this.processorNode = null;
    }
    if (this.muteGainNode) {
      this.muteGainNode.disconnect();
      this.muteGainNode = null;
    }
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
    this.recorder = null;
  }
  registerGlobalHotkey() {
    if (!this.electron || !this.settings.muteHotkey)
      return;
    try {
      const remote = this.electron.remote || this.electron;
      const { globalShortcut } = remote;
      this.unregisterGlobalHotkey();
      const registered = globalShortcut.register(
        this.settings.muteHotkey,
        () => {
          this.toggleMute();
        }
      );
      if (!registered) {
        console.warn(
          `Failed to register global hotkey: ${this.settings.muteHotkey}`
        );
      }
    } catch (err) {
      console.error("Error registering global hotkey:", err);
    }
  }
  unregisterGlobalHotkey() {
    if (!this.electron || !this.settings.muteHotkey)
      return;
    try {
      const remote = this.electron.remote || this.electron;
      const { globalShortcut } = remote;
      if (globalShortcut.isRegistered(this.settings.muteHotkey)) {
        globalShortcut.unregister(this.settings.muteHotkey);
      }
    } catch (err) {
      console.error("Error unregistering global hotkey:", err);
    }
  }
  async saveRecording(blob) {
    let buffer;
    if (this.settings.outputFormat === "webm") {
      const duration = Date.now() - this.startTime;
      const fixedBlob = await new Promise((resolve) => {
        (0, import_fix_webm_duration.default)(blob, duration, (fixed) => {
          resolve(fixed);
        });
      });
      const arrayBuffer = await fixedBlob.arrayBuffer();
      buffer = new Uint8Array(arrayBuffer);
    } else {
      const arrayBuffer = await blob.arrayBuffer();
      buffer = new Uint8Array(arrayBuffer);
    }
    const folderPath = this.settings.recordingsFolder;
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
    const now = new Date();
    const timestamp = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, "0")}-${now.getDate().toString().padStart(2, "0")} ${now.getHours().toString().padStart(2, "0")}.${now.getMinutes().toString().padStart(2, "0")}.${now.getSeconds().toString().padStart(2, "0")}`;
    const extension = this.settings.outputFormat;
    const filename = `${folderPath}/Recording ${timestamp}.${extension}`;
    const file = await this.app.vault.createBinary(filename, buffer.buffer);
    if (this.transcriptionText.trim()) {
      const transcriptFilename = `${folderPath}/Recording ${timestamp} Transcript.md`;
      const transcriptContent = this.transcriptionText.trim();
      await this.app.vault.create(transcriptFilename, transcriptContent);
    }
    if (this.activeFileAtStart) {
      let linkText = `
![[${file.path}]]
`;
      if (this.transcriptionText.trim()) {
        linkText += `
> [!info]- Transcript
`;
        linkText += `> ${this.transcriptionText.trim().replace(/\n/g, "\n> ")}
`;
      }
      await this.app.vault.append(this.activeFileAtStart, linkText);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  interleave(leftChannel, rightChannel) {
    const length = leftChannel.length + rightChannel.length;
    const result = new Float32Array(length);
    let inputIndex = 0;
    for (let index = 0; index < length; ) {
      result[index++] = leftChannel[inputIndex];
      result[index++] = rightChannel[inputIndex];
      inputIndex++;
    }
    return result;
  }
  convertFloat32ToInt16(buffer) {
    let l = buffer.length;
    const buf = new Int16Array(l);
    while (l--) {
      buf[l] = Math.min(1, Math.max(-1, buffer[l])) * 32767;
    }
    return buf;
  }
  createWavFile(audioData, targetSampleRate) {
    const ratio = this.sampleRate / targetSampleRate;
    const newLength = Math.round(audioData.length / ratio);
    const resampled = new Float32Array(newLength);
    for (let i = 0; i < newLength; i++) {
      const srcIndex = i * ratio;
      const srcIndexFloor = Math.floor(srcIndex);
      const srcIndexCeil = Math.min(srcIndexFloor + 1, audioData.length - 1);
      const t = srcIndex - srcIndexFloor;
      resampled[i] = audioData[srcIndexFloor] * (1 - t) + audioData[srcIndexCeil] * t;
    }
    const buffer = new ArrayBuffer(44 + resampled.length * 2);
    const view = new DataView(buffer);
    this.writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + resampled.length * 2, true);
    this.writeString(view, 8, "WAVE");
    this.writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, targetSampleRate, true);
    view.setUint32(28, targetSampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    this.writeString(view, 36, "data");
    view.setUint32(40, resampled.length * 2, true);
    this.floatTo16BitPCM(view, 44, resampled);
    return view;
  }
  writeWavHeader(samples) {
    const buffer = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(buffer);
    this.writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + samples.length * 2, true);
    this.writeString(view, 8, "WAVE");
    this.writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, this.numChannels, true);
    view.setUint32(24, this.sampleRate, true);
    view.setUint32(28, this.sampleRate * 4, true);
    view.setUint16(32, this.numChannels * 2, true);
    view.setUint16(34, 16, true);
    this.writeString(view, 36, "data");
    view.setUint32(40, samples.length * 2, true);
    this.floatTo16BitPCM(view, 44, samples);
    return view;
  }
  floatTo16BitPCM(output, offset, input) {
    for (let i = 0; i < input.length; i++, offset += 2) {
      const s = Math.max(-1, Math.min(1, input[i]));
      output.setInt16(offset, s < 0 ? s * 32768 : s * 32767, true);
    }
  }
  writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
};
var AudioRecorderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Audio Recorder" });
    new import_obsidian.Setting(containerEl).setName("Recordings Folder").setDesc("Folder to save audio recordings in").addText(
      (text) => text.setPlaceholder("Recordings").setValue(this.plugin.settings.recordingsFolder).onChange(async (value) => {
        this.plugin.settings.recordingsFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Record Microphone").setDesc("Record microphone audio along with system audio.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.recordMicrophone).onChange(async (value) => {
        this.plugin.settings.recordMicrophone = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Microphone Source").setDesc("Select the microphone to record.").addDropdown(async (dropdown) => {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter((d) => d.kind === "audioinput");
      audioInputs.forEach((device) => {
        dropdown.addOption(
          device.deviceId,
          device.label || `Microphone ${device.deviceId}`
        );
      });
      dropdown.setValue(this.plugin.settings.selectedMicrophoneId);
      dropdown.onChange(async (value) => {
        this.plugin.settings.selectedMicrophoneId = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Output Format").setDesc("Select the audio output format.").addDropdown((dropdown) => {
      dropdown.addOption("webm", "WebM").addOption("wav", "WAV").setValue(this.plugin.settings.outputFormat).onChange(async (value) => {
        this.plugin.settings.outputFormat = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Live Transcription" });
    new import_obsidian.Setting(containerEl).setName("Enable Live Transcription").setDesc(
      "Enable live transcription during recording. Requires whisper.cpp to be installed locally."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableTranscription).onChange(async (value) => {
        this.plugin.settings.enableTranscription = value;
        await this.plugin.saveSettings();
      })
    );
    const fs = require("fs");
    const path2 = require("path");
    const os = require("os");
    const executableDir = path2.join(
      this.app.vault.adapter.getBasePath(),
      ".obsidian",
      "plugins",
      this.plugin.manifest.id,
      "bin"
    );
    const platform = os.platform();
    let executableName = "main";
    if (platform === "win32") {
      executableName = "main.exe";
    }
    const executablePath = path2.join(executableDir, executableName);
    const executableExists = fs.existsSync(executablePath);
    const executableSetting = new import_obsidian.Setting(containerEl).setName("Whisper.cpp Executable").setDesc(
      executableExists ? `Installed at: ${executablePath}` : "Not found. Click the button to download whisper.cpp automatically."
    );
    executableSetting.addButton((button) => {
      button.setButtonText(
        executableExists ? "Re-download" : "Download whisper.cpp"
      ).setCta().onClick(async () => {
        button.setDisabled(true);
        button.setButtonText("Downloading...");
        const statusDiv = containerEl.createDiv();
        statusDiv.addClass("setting-item-description");
        statusDiv.style.marginTop = "0.5em";
        statusDiv.style.color = "#7c3aed";
        statusDiv.setText("Detecting platform and downloading...");
        try {
          await this.downloadWhisperCpp((status) => {
            statusDiv.setText(status);
          });
          statusDiv.style.color = "#10b981";
          statusDiv.setText("Download complete!");
          button.setButtonText("Re-download");
          executableSetting.setDesc(`Installed at: ${executablePath}`);
          this.plugin.settings.whisperCppPath = executablePath;
          await this.plugin.saveSettings();
          setTimeout(() => {
            statusDiv.remove();
          }, 3e3);
        } catch (err) {
          statusDiv.style.color = "#ef4444";
          statusDiv.setText(`Error: ${err.message}`);
          button.setButtonText(
            executableExists ? "Re-download" : "Download whisper.cpp"
          );
        } finally {
          button.setDisabled(false);
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Whisper Model").setDesc(
      "Select which model to use. Smaller models are faster but less accurate. English-only models (.en) are faster for English."
    ).addDropdown((dropdown) => {
      dropdown.addOption("tiny", "Tiny (~75MB) - Fastest, least accurate").addOption("tiny.en", "Tiny English (~75MB) - Fastest for English").addOption("base", "Base (~150MB) - Balanced").addOption("base.en", "Base English (~150MB) - Balanced for English").addOption("small", "Small (~500MB) - Good accuracy").addOption("small.en", "Small English (~500MB) - Good for English").addOption("medium", "Medium (~1.5GB) - High accuracy").addOption("medium.en", "Medium English (~1.5GB) - High for English").addOption("large-v1", "Large v1 (~3GB) - Best accuracy").addOption("large-v2", "Large v2 (~3GB) - Best accuracy").addOption("large-v3", "Large v3 (~3GB) - Best accuracy, latest").setValue(this.plugin.settings.whisperModel).onChange(async (value) => {
        this.plugin.settings.whisperModel = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const modelDir = path2.join(
      this.app.vault.adapter.getBasePath(),
      ".obsidian",
      "plugins",
      this.plugin.manifest.id,
      "models"
    );
    const modelPath = path2.join(
      modelDir,
      `ggml-${this.plugin.settings.whisperModel}.bin`
    );
    const modelExists = fs.existsSync(modelPath);
    const modelSetting = new import_obsidian.Setting(containerEl).setName("Whisper Model").setDesc(
      modelExists ? `Model installed at: ${modelPath}` : "Model not found. Click the button to download (~150MB)."
    );
    modelSetting.addButton((button) => {
      button.setButtonText(modelExists ? "Re-download Model" : "Download Model").setCta().onClick(async () => {
        button.setDisabled(true);
        button.setButtonText("Downloading...");
        const statusDiv = containerEl.createDiv();
        statusDiv.addClass("setting-item-description");
        statusDiv.style.marginTop = "0.5em";
        statusDiv.style.color = "#7c3aed";
        statusDiv.setText("Starting download...");
        try {
          if (modelExists) {
            try {
              fs.unlinkSync(modelPath);
            } catch (err) {
              console.warn("Could not delete existing model:", err);
            }
          }
          await this.downloadModelWithProgress((progress) => {
            statusDiv.setText(`Downloading: ${progress}%`);
          });
          statusDiv.style.color = "#10b981";
          statusDiv.setText("Download complete!");
          button.setButtonText("Re-download Model");
          modelSetting.setDesc(`Model installed at: ${modelPath}`);
          setTimeout(() => {
            statusDiv.remove();
          }, 3e3);
        } catch (err) {
          statusDiv.style.color = "#ef4444";
          statusDiv.setText(`Error: ${err.message}`);
          button.setButtonText(
            modelExists ? "Re-download Model" : "Download Model"
          );
        } finally {
          button.setDisabled(false);
        }
      });
    });
    const instructionsDiv = containerEl.createDiv();
    instructionsDiv.addClass("setting-item-description");
    instructionsDiv.style.marginBottom = "1em";
    instructionsDiv.style.padding = "0.5em";
    instructionsDiv.style.backgroundColor = "var(--background-secondary)";
    instructionsDiv.style.borderRadius = "4px";
    instructionsDiv.innerHTML = `
      <strong>\u{1F4DD} Setup Instructions:</strong><br>
      1. Click "Download whisper.cpp" above<br>
      2. Click "Download Model" below<br>
      3. Enable transcription and start recording!
    `;
    containerEl.createEl("h3", { text: "Hotkeys" });
    new import_obsidian.Setting(containerEl).setName("Global Mute Hotkey").setDesc(
      "Set a system-wide hotkey to toggle microphone muting (works even when Obsidian isn't focused). Uses Electron's accelerator format. Examples: 'CommandOrControl+Shift+M', 'Alt+M', 'Ctrl+Shift+Space'. Changes take effect when starting a new recording."
    ).addText(
      (text) => text.setPlaceholder("CommandOrControl+Shift+M").setValue(this.plugin.settings.muteHotkey).onChange(async (value) => {
        this.plugin.settings.muteHotkey = value;
        await this.plugin.saveSettings();
      })
    );
    const hotkeyDesc = containerEl.createDiv();
    hotkeyDesc.addClass("setting-item-description");
    hotkeyDesc.setText(
      "You can also use Obsidian's built-in hotkeys (Settings \u2192 Hotkeys \u2192 'Toggle Microphone Mute'), but those only work when Obsidian is focused."
    );
    hotkeyDesc.style.marginBottom = "1em";
  }
  async downloadWhisperCpp(statusCallback) {
    const fs = require("fs");
    const path2 = require("path");
    const os = require("os");
    const https = require("https");
    const platform = os.platform();
    const arch = os.arch();
    const binDir = path2.join(
      this.app.vault.adapter.getBasePath(),
      ".obsidian",
      "plugins",
      this.plugin.manifest.id,
      "bin"
    );
    if (!fs.existsSync(binDir)) {
      fs.mkdirSync(binDir, { recursive: true });
    }
    let executableName = "main";
    let downloadUrl = "";
    if (platform === "win32") {
      executableName = "main.exe";
      if (arch === "x64") {
        downloadUrl = "https://github.com/ggerganov/whisper.cpp/releases/download/v1.8.2/whisper-bin-x64.zip";
      } else {
        executableName = "main.exe";
        downloadUrl = "https://github.com/ggerganov/whisper.cpp/releases/download/v1.8.2/whisper-bin-Win32.zip";
      }
    } else if (platform === "darwin") {
      throw new Error(
        "Automatic download not available for macOS. Please install via Homebrew: brew install whisper-cpp"
      );
    } else if (platform === "linux") {
      throw new Error(
        "Automatic download not available for Linux. Please build from source: https://github.com/ggerganov/whisper.cpp"
      );
    } else {
      throw new Error(`Unsupported platform: ${platform}`);
    }
    const executablePath = path2.join(binDir, executableName);
    statusCallback("Downloading whisper.cpp...");
    return new Promise((resolve, reject) => {
      const zipPath = path2.join(binDir, "whisper.zip");
      const file = fs.createWriteStream(zipPath);
      let downloadedBytes = 0;
      let totalBytes = 0;
      file.on("error", (err) => {
        console.error("File write stream error:", err);
        reject(err);
      });
      const followRedirects = (url, depth = 0) => {
        if (depth > 10) {
          reject(new Error("Too many redirects (>10)"));
          return;
        }
        https.get(url, (response) => {
          if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307 || response.statusCode === 308) {
            const redirectUrl = response.headers.location;
            response.resume();
            followRedirects(redirectUrl, depth + 1);
          } else if (response.statusCode === 200) {
            totalBytes = parseInt(
              response.headers["content-length"] || "0",
              10
            );
            response.on("data", (chunk) => {
              downloadedBytes += chunk.length;
              const progress = Math.floor(
                downloadedBytes / totalBytes * 100
              );
              statusCallback(`Downloading whisper.cpp: ${progress}%`);
            });
            response.on("error", (err) => {
              console.error("Response stream error:", err);
              file.close();
              fs.unlink(zipPath, () => {
              });
              reject(err);
            });
            response.pipe(file);
            file.on("finish", () => {
              file.close(() => {
                const stats = fs.statSync(zipPath);
                if (stats.size === 0) {
                  reject(new Error("Downloaded file is empty"));
                  return;
                }
                if (stats.size < 1e3) {
                  reject(
                    new Error(
                      "Downloaded file appears to be invalid or corrupted"
                    )
                  );
                  return;
                }
                statusCallback("Extracting...");
                try {
                  const { execSync } = require("child_process");
                  if (platform === "win32") {
                    const zipPathPS = zipPath.replace(/\\/g, "/");
                    const binDirPS = binDir.replace(/\\/g, "/");
                    try {
                      const command = `powershell -NoProfile -ExecutionPolicy Bypass -Command "Add-Type -AssemblyName System.IO.Compression.FileSystem; [System.IO.Compression.ZipFile]::ExtractToDirectory('${zipPathPS}', '${binDirPS}'); Write-Output 'Done'"`;
                      execSync(command, {
                        encoding: "utf8"
                      });
                    } catch (e) {
                      try {
                        const psCommand = `Expand-Archive -LiteralPath '${zipPath}' -DestinationPath '${binDir}' -Force`;
                        execSync(
                          `powershell -NoProfile -ExecutionPolicy Bypass -Command "${psCommand}"`,
                          {
                            encoding: "utf8"
                          }
                        );
                      } catch (e2) {
                        throw new Error(
                          `Failed to extract archive: ${e2.message}`
                        );
                      }
                    }
                  } else {
                    execSync(`unzip -o "${zipPath}" -d "${binDir}"`, {
                      encoding: "utf8"
                    });
                  }
                  let extractedFiles = fs.readdirSync(binDir);
                  let found = false;
                  if (extractedFiles.length === 1 && extractedFiles[0] === "whisper.zip") {
                    console.error(
                      "Extraction appears to have failed - only zip file present"
                    );
                    throw new Error(
                      "Failed to extract whisper.cpp archive. The download may be corrupted or the archive format is unsupported."
                    );
                  }
                  for (const extractedFile of extractedFiles) {
                    if (extractedFile.endsWith(".zip") && extractedFile !== "whisper.zip") {
                      const nestedZipPath = path2.join(binDir, extractedFile);
                      const tempExtractDir = path2.join(
                        binDir,
                        "temp_extract"
                      );
                      if (!fs.existsSync(tempExtractDir)) {
                        fs.mkdirSync(tempExtractDir, { recursive: true });
                      }
                      const nestedZipPathPS = nestedZipPath.replace(
                        /\\/g,
                        "/"
                      );
                      const tempExtractDirPS = tempExtractDir.replace(
                        /\\/g,
                        "/"
                      );
                      try {
                        const command = `powershell -NoProfile -ExecutionPolicy Bypass -Command "Add-Type -AssemblyName System.IO.Compression.FileSystem; [System.IO.Compression.ZipFile]::ExtractToDirectory('${nestedZipPathPS}', '${tempExtractDirPS}'); Write-Output 'Done'"`;
                        execSync(command, {
                          encoding: "utf8"
                        });
                      } catch (e) {
                        try {
                          const psCommand2 = `Expand-Archive -LiteralPath '${nestedZipPath}' -DestinationPath '${tempExtractDir}' -Force`;
                          execSync(
                            `powershell -NoProfile -ExecutionPolicy Bypass -Command "${psCommand2}"`,
                            {
                              encoding: "utf8"
                            }
                          );
                        } catch (e2) {
                          throw new Error(
                            `Failed to extract nested archive: ${e2.message}`
                          );
                        }
                      }
                      const tempFiles = fs.readdirSync(tempExtractDir);
                      for (const tempFile of tempFiles) {
                        const srcPath = path2.join(tempExtractDir, tempFile);
                        const destPath = path2.join(binDir, tempFile);
                        if (fs.existsSync(destPath)) {
                          if (fs.statSync(destPath).isDirectory()) {
                            fs.rmSync(destPath, { recursive: true });
                          } else {
                            fs.unlinkSync(destPath);
                          }
                        }
                        fs.renameSync(srcPath, destPath);
                      }
                      fs.rmdirSync(tempExtractDir);
                      fs.unlinkSync(nestedZipPath);
                      extractedFiles = fs.readdirSync(binDir);
                      break;
                    }
                  }
                  for (const extractedFile of extractedFiles) {
                    if (extractedFile === "main.exe" || extractedFile === "main" || extractedFile === "whisper.exe" || extractedFile === "whisper") {
                      const extractedPath = path2.join(binDir, extractedFile);
                      if (extractedPath !== executablePath) {
                        fs.renameSync(extractedPath, executablePath);
                      }
                      found = true;
                      break;
                    }
                  }
                  if (!found) {
                    for (const extractedFile of extractedFiles) {
                      const fullPath = path2.join(binDir, extractedFile);
                      try {
                        if (fs.statSync(fullPath).isDirectory()) {
                          const subFiles = fs.readdirSync(fullPath);
                          const hasWhisperCli = subFiles.includes("whisper-cli.exe");
                          const hasMainExe = subFiles.includes("main.exe");
                          if (hasWhisperCli || hasMainExe) {
                            for (const subFile of subFiles) {
                              const srcPath = path2.join(fullPath, subFile);
                              const destPath = path2.join(binDir, subFile);
                              try {
                                if (fs.statSync(srcPath).isFile()) {
                                  fs.copyFileSync(srcPath, destPath);
                                }
                              } catch (copyErr) {
                                console.error(
                                  `Failed to copy ${subFile}:`,
                                  copyErr.message
                                );
                              }
                            }
                            const preferredExe = hasWhisperCli ? "whisper-cli.exe" : "main.exe";
                            const srcExe = path2.join(binDir, preferredExe);
                            if (fs.existsSync(srcExe) && srcExe !== executablePath) {
                              fs.renameSync(srcExe, executablePath);
                            }
                            try {
                              fs.rmSync(fullPath, {
                                recursive: true,
                                force: true
                              });
                            } catch (cleanupErr) {
                            }
                            found = true;
                            break;
                          }
                        }
                      } catch (e) {
                        console.error(
                          `Error checking ${extractedFile}:`,
                          e.message
                        );
                      }
                    }
                  }
                  if (platform !== "win32") {
                    fs.chmodSync(executablePath, 493);
                  }
                  try {
                    fs.unlinkSync(zipPath);
                  } catch (e) {
                  }
                  if (found) {
                    resolve(executablePath);
                  } else {
                    reject(
                      new Error(
                        "Could not find main executable in downloaded archive"
                      )
                    );
                  }
                } catch (err) {
                  reject(err);
                }
              });
            });
          } else {
            console.error(
              `[Depth ${depth}] Unexpected status: ${response.statusCode}`
            );
            reject(
              new Error(
                `Download failed with status: ${response.statusCode}`
              )
            );
          }
        }).on("error", (err) => {
          console.error(`[Depth ${depth}] Request error:`, err);
          fs.unlink(zipPath, () => {
          });
          reject(err);
        });
      };
      followRedirects(downloadUrl);
    });
  }
  async downloadModelWithProgress(progressCallback) {
    const fs = require("fs");
    const path2 = require("path");
    const https = require("https");
    const modelDir = path2.join(
      this.app.vault.adapter.getBasePath(),
      ".obsidian",
      "plugins",
      this.plugin.manifest.id,
      "models"
    );
    if (!fs.existsSync(modelDir)) {
      fs.mkdirSync(modelDir, { recursive: true });
    }
    const modelName = `ggml-${this.plugin.settings.whisperModel}.bin`;
    const modelPath = path2.join(modelDir, modelName);
    const modelUrl = `https://huggingface.co/ggerganov/whisper.cpp/resolve/main/${modelName}`;
    return new Promise((resolve, reject) => {
      const file = fs.createWriteStream(modelPath);
      let downloadedBytes = 0;
      let totalBytes = 0;
      let lastReportedProgress = 0;
      https.get(modelUrl, (response) => {
        if (response.statusCode === 302 || response.statusCode === 301) {
          https.get(response.headers.location, (redirectResponse) => {
            totalBytes = parseInt(
              redirectResponse.headers["content-length"],
              10
            );
            redirectResponse.on("data", (chunk) => {
              downloadedBytes += chunk.length;
              const progress = Math.floor(
                downloadedBytes / totalBytes * 100
              );
              if (progress > lastReportedProgress) {
                lastReportedProgress = progress;
                progressCallback(progress.toString());
              }
            });
            redirectResponse.pipe(file);
            file.on("finish", () => {
              file.close();
              resolve(modelPath);
            });
          }).on("error", (err) => {
            fs.unlink(modelPath, () => {
            });
            reject(err);
          });
        } else {
          totalBytes = parseInt(response.headers["content-length"], 10);
          response.on("data", (chunk) => {
            downloadedBytes += chunk.length;
            const progress = Math.floor(downloadedBytes / totalBytes * 100);
            if (progress > lastReportedProgress) {
              lastReportedProgress = progress;
              progressCallback(progress.toString());
            }
          });
          response.pipe(file);
          file.on("finish", () => {
            file.close();
            resolve(modelPath);
          });
        }
      }).on("error", (err) => {
        fs.unlink(modelPath, () => {
        });
        reject(err);
      });
    });
  }
};
